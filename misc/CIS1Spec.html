<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>CIS1Spec.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.11.0+0.11.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="doc">
<a name="lab1"></a><h1 class="section">Concordium's CIS1</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
See the original CIS1 standard: http://proposals.concordium.software/CIS/cis-1.html 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
 The formalisation defines module types that specify what functionality should be
 provided by a function that implements the standard.

<div class="paragraph"> </div>

Covered by the formalisation:

<div class="paragraph"> </div>
<ul class="doclist">
<li> Specifications of <span class="inlinecode"><span class="id" title="var">transfer</span></span>, <span class="inlinecode"><span class="id" title="var">balanceOf</span></span> and <span class="inlinecode"><span class="id" title="var">operatorUpdate</span></span>.

<div class="paragraph"> </div>
</li>
<li> Proofs that these functions peserve the sum of all balances for all token ids. The properties hold for any contract that satisfies the CIS1 specification defined in this formalisation.

<div class="paragraph"> </div>

 Not covered by the fomalisation:

<div class="paragraph"> </div>
</li>
<li> Concordium serialisation.

<div class="paragraph"> </div>
</li>
<li> Logging the events (logs are currently not supported by ConCert).

<div class="paragraph"> </div>
</li>
<li> Metadata.

</li>
</ul>
<div class="paragraph"> </div>
<div class="paragraph"> </div>

The approach to formalisation is inspired by Murdoch Gabbay, Arvid Jakobsson, Kristina Sojakova. Money grows on (proof-)trees: the formal FA1.2 ledger standard.

<div class="paragraph"> </div>

The CIS1 standard is, however, more general:

<div class="paragraph"> </div>
<ul class="doclist">
<li> the standard allows for multiple tokens on obe contracts, which makes it possible to define both fungible and non-fungible tokens;

<div class="paragraph"> </div>
</li>
<li> the transfers happen in batch mode.

<div class="paragraph"> </div>
</li>
</ul>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> ConCert.Execution <span class="kn">Require Import</span> Blockchain.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> ConCert.Execution <span class="kn">Require Import</span> Serializable.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> ConCert.Execution.Examples <span class="kn">Require Import</span> Common.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> ConCert.Execution.Standards.CIS1 <span class="kn">Require Import</span> CIS1Utils.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> MetaCoq.Template <span class="kn">Require Import</span> monad_utils.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Basics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ZArith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> MonadNotation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> RemoveProperties.</span></span></pre><div class="doc">
<a name="lab2"></a><h2 class="section">General types</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
NOTE: In CIS1 it's an n-byte sequence, where 0 &lt;= n &lt;= 256.
   We model it as an unbounded number <span class="inlinecode"><span class="id" title="var">nat</span></span>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TokenID</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TokenAmount</span> := nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> program_scope.</span></span></pre><div class="doc">
Supported entry points 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">CIS1_entry_points</span> :=
| CIS1_transfer
| CIS1_updateOperator
| CIS1_balanceOf.</span></span></pre><div class="doc">
CIS1: <span class="inlinecode"><span class="id" title="var">ReceiveHookParameter</span></span> <span class="inlinecode">::=</span> <span class="inlinecode">(<span class="id" title="var">id</span>:</span> <span class="inlinecode"><span class="id" title="var">TokenID</span>)</span> <span class="inlinecode">(<span class="id" title="var">amount</span>:</span> <span class="inlinecode"><span class="id" title="var">TokenAmount</span>)</span> <span class="inlinecode">(<span class="id" title="var">from</span>:</span> <span class="inlinecode"><span class="id" title="var">Address</span>)</span>
<span class="inlinecode">(<span class="id" title="var">contract</span>:</span> <span class="inlinecode"><span class="id" title="var">ContractName</span>)</span> <span class="inlinecode">(<span class="id" title="var">data</span>:</span> <span class="inlinecode"><span class="id" title="var">AdditionalData</span>)</span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
NOTE: there is no notion of a contract name in ConCert; <span class="inlinecode"><span class="id" title="var">AdditionalData</span></span> is not handled at the moment 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">receive_hook_params</span> `{ChainBase} : <span class="kt">Type</span> := TokenID * TokenAmount * Address.</span></span></pre><div class="doc">
All addresses owning tokens must supoort the following interface, since all receiving
    addresses are notified with a receive hook. The rest of the functionality is captured
    by the <span class="inlinecode"><span class="id" title="var">other_msg</span></span> constructor 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">CIS1ReceiverMsg</span> (<span class="nv">Msg</span> : <span class="kt">Type</span>) `{Serializable Msg} `{ChainBase} :=
| CIS1_receiver_receive_hook : receive_hook_params -&gt; CIS1ReceiverMsg Msg
| CIS1_receiver_other_msg : Msg -&gt; CIS1ReceiverMsg Msg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* begin hide *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">CIS1ReceiverMsg_serializable</span> {<span class="nv">Msg</span> : <span class="kt">Type</span>} `{serMsg : Serializable Msg} `{cb : ChainBase} : Serializable (@CIS1ReceiverMsg Msg serMsg _) :=
  <span class="kn">Derive</span> <span class="nf">Serializable</span> (@CIS1ReceiverMsg_rect Msg serMsg cb) &lt;
    (@CIS1_receiver_receive_hook Msg serMsg cb),
    (@CIS1_receiver_other_msg Msg serMsg cb)&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* end hide *)</span></span></pre><div class="doc">
Abstract types of messages and storage (the contract's state) 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module Type</span> <span class="nf">CIS1Types</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">Msg</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">Storage</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CIS1Types</span>.</span></span></pre><div class="doc">
<a name="lab3"></a><h2 class="section">Views</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
A module type that defines a view interface. The interface specifies functions for
    observing the contract's state. These functions are used to defined the specification.  
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module Type</span> <span class="nf">CIS1View</span> (cis1_types : CIS1Types).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> cis1_types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">get_CIS1_entry_point</span> : Msg -&gt; option CIS1_entry_points.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">get_balance_opt</span> : <span class="kr">forall</span> `{ChainBase}, Storage -&gt; TokenID -&gt; Address -&gt; option TokenAmount.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">get_operators</span> : <span class="kr">forall</span> `{ChainBase}, Storage -&gt; Address -&gt; list Address.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">get_owners</span> : <span class="kr">forall</span> `{ChainBase}, Storage -&gt; TokenID -&gt; list Address.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">get_owners_no_dup</span> : <span class="kr">forall</span> `{ChainBase} st token_id, NoDup (get_owners st token_id).</span></span></pre><div class="doc">
Owners determined by their balances 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">get_owners_balances</span> : <span class="kr">forall</span> `{ChainBase} st owner token_id,
    In owner (get_owners st token_id) &lt;-&gt;
    <span class="kr">exists</span> <span class="nv">balance</span>, get_balance_opt st token_id owner = Some balance.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">token_id_exists</span> : Storage -&gt; TokenID -&gt; bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">get_token_ids</span> : Storage -&gt; list TokenID.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_balance</span> `{ChainBase} : Storage -&gt; TokenID -&gt; Address -&gt; option TokenAmount :=
    <span class="kr">fun</span> <span class="nv">st</span> <span class="nv">token_id</span> <span class="nv">addr</span> =&gt; <span class="kr">if</span> token_id_exists st token_id <span class="kr">then</span>
                              <span class="kr">match</span> get_balance_opt st token_id addr <span class="kr">with</span>
                              | Some bal =&gt; Some bal
                              | None =&gt; Some <span class="mi">0</span>
                              <span class="kr">end</span>
                            <span class="kr">else</span> None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_balance_total</span> `{ChainBase}
             (st : Storage)
             (token_id : TokenID)
             (p : token_id_exists st token_id = true)
             (addr : Address) : TokenAmount :=
    <span class="kr">let</span> <span class="nv">o</span> := get_balance st token_id addr <span class="kr">in</span>
    <span class="kr">match</span> o <span class="kr">as</span> o&#39; <span class="kr">return</span> (o&#39; = o -&gt; _) <span class="kr">with</span>
    | Some bal =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; bal
    | None =&gt; <span class="kr">fun</span> <span class="nv">heq</span> =&gt; False_rect _ (<span class="kp">ltac</span>:(<span class="nb">intros</span>;<span class="nb">subst</span> o; <span class="nb">unfold</span> get_balance <span class="kr">in</span> *;<span class="nb">rewrite</span> p <span class="kr">in</span> *;
    <span class="nb">destruct</span> (get_balance_opt st token_id addr);<span class="bp">congruence</span>))
    <span class="kr">end</span> eq_refl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CIS1View</span>.</span></span></pre><div class="doc">
The module below specifies an abstract interface of the CIS1 token along with the properties
    that must be satisfied by each entry point required by the standard. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module Type</span> <span class="nf">CIS1Axioms</span> (cis1_types : CIS1Types) (cis1_view : CIS1View cis1_types).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> cis1_types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> cis1_view.</span></span></pre><div class="doc">
<a name="lab4"></a><h2 class="section">Contract functions</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
CIS1: A smart contract implementing CIS1 MUST export three functions <span class="inlinecode"><span class="id" title="var">transfer</span></span>, <span class="inlinecode"><span class="id" title="var">updateOperator</span></span> and <span class="inlinecode"><span class="id" title="var">balanceOf</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">supports_transfer</span> : <span class="kr">exists</span> <span class="nv">msg</span>, get_CIS1_entry_point msg = Some CIS1_transfer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">supports_updateOperator</span> : <span class="kr">exists</span> <span class="nv">msg</span>, get_CIS1_entry_point msg = Some CIS1_transfer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">supports_blanceOf</span> : <span class="kr">exists</span> <span class="nv">msg</span>, get_CIS1_entry_point msg = Some CIS1_balanceOf.</span></span></pre><div class="doc">
<a name="lab5"></a><h3 class="section">Transfer</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
<a name="lab6"></a><h4 class="section">Parameter</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
NOTE: not handling additional data at the moment 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_transfer_data</span> `{ChainBase} :=
  { cis1_td_token_id : TokenID;
    cis1_td_amount   : TokenAmount;
    cis1_td_from     : Address;
    cis1_td_to       : Address }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_transfer_params</span> `{ChainBase} :=
    { cis_tr_transfers : list CIS1_transfer_data }.</span></span></pre><div class="doc">
Some utils for getting data from the parameters. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transfer_to</span> `{ChainBase} : CIS1_transfer_params -&gt; list (TokenID * Address) :=
    <span class="kr">fun</span> <span class="nv">params</span> =&gt; map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x.(cis1_td_token_id), x.(cis1_td_to))) params.(cis_tr_transfers).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transfer_from</span> `{ChainBase} : CIS1_transfer_params -&gt; list (TokenID * Address) :=
  <span class="kr">fun</span> <span class="nv">params</span> =&gt; map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x.(cis1_td_token_id), x.(cis1_td_from))) params.(cis_tr_transfers).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_receive_hook_params</span> `{ChainBase} (params : list CIS1_transfer_data)
  : list (Address * receive_hook_params) :=
  map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x.(cis1_td_to), (x.(cis1_td_token_id), x.(cis1_td_amount), x.(cis1_td_from)))) params.</span></span></pre><div class="doc">
<a name="lab7"></a><h4 class="section">Requirements</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
A specification for a single transfer of a particular token id between <span class="inlinecode"><span class="id" title="var">from</span></span> and <span class="inlinecode"><span class="id" title="var">to</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transfer_single_spec</span>
             `{ChainBase}
             (prev_st next_st : Storage)
             (token_id : TokenID)
             (p : token_id_exists prev_st token_id = true)
             (q : token_id_exists next_st token_id = true)
             (<span class="kn">from</span> : Address)
             (to : Address)
             (amount : TokenAmount) : <span class="kt">Prop</span> :=
    <span class="kr">let</span> <span class="nv">prev_from</span> := get_balance_total prev_st token_id p <span class="kn">from</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">next_from</span> := get_balance_total next_st token_id q <span class="kn">from</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">prev_to</span> := get_balance_total prev_st token_id p to <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">next_to</span> := get_balance_total next_st token_id q to <span class="kr">in</span>
    <span class="sd">(** The balances that are not [to] and [from] (for the token with [token_id]) remain unchanged *)</span>
    (<span class="kr">forall</span> <span class="nv">addr</span>, addr &lt;&gt; <span class="kn">from</span> -&gt;
             addr &lt;&gt; to -&gt;
             get_balance_opt next_st token_id addr = get_balance_opt prev_st token_id addr) /\
    <span class="sd">(** The balances of all other tokens that are not equal to [token_id] remain unchanged for all addresses *)</span>
    (<span class="kr">forall</span> <span class="nv">addr</span> <span class="nv">other_token_id</span>, other_token_id &lt;&gt; token_id -&gt;
                            get_balance_opt next_st other_token_id addr = get_balance_opt prev_st other_token_id addr) /\
    <span class="sd">(** Token ids are preserved by a single transfer *)</span>
    (<span class="kr">forall</span> <span class="nv">token_id</span>,
        token_id_exists prev_st token_id =  token_id_exists next_st token_id) /\
    <span class="sd">(** CIS1: A transfer MUST non-strictly decrease the balance of the from address and non-strictly increase the balance of the to address *)</span>
    prev_from = next_from + amount /\
    next_to = prev_to + amount.</span></span></pre><div class="doc">
CIS1: The list of transfers MUST be executed in order. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">compose_transfers</span>
           `{ChainBase}
           (init_st : Storage)
           (final_st : Storage)
           (params : list CIS1_transfer_data)
           (single_transfer :
              <span class="kr">forall</span> (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage)
                     (<span class="nv">params</span> : CIS1_transfer_data),
                token_id_exists prev_st params.(cis1_td_token_id) = true -&gt;
                token_id_exists next_st params.(cis1_td_token_id) = true -&gt; <span class="kt">Prop</span>)
    : <span class="kt">Prop</span> :=
    <span class="kr">match</span> params <span class="kr">with</span>
    | [] =&gt; init_st = final_st
    | pr :: ps =&gt;
     <span class="sd">(** NOTE: we require that for each transfer, the updated state [st] becomes the initial state for the next transfer *)</span>
      <span class="kr">exists</span> (<span class="nv">st</span> : Storage)
        (<span class="nv">p</span>: token_id_exists init_st pr.(cis1_td_token_id) = true)
        (<span class="nv">q</span> : token_id_exists st pr.(cis1_td_token_id) = true),
      single_transfer init_st st pr p q /\ compose_transfers st final_st ps single_transfer
    <span class="kr">end</span>.</span></span></pre><div class="doc">
A receive hook call is valid if the call parameters are deserialised to a <span class="inlinecode"><span class="id" title="var">CIS1_receiver_receive_hook</span></span>
      constructor with appropriate data 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_valid_receive_hook</span> `{cb : ChainBase} (p : receive_hook_params) (serialized_params : SerializedValue) : <span class="kt">Prop</span> :=
    <span class="kr">exists</span> (<span class="nv">Msg</span> : <span class="kt">Type</span>) (<span class="nv">sMsg</span> : Serializable Msg) (<span class="nv">msg</span> : @CIS1ReceiverMsg Msg sMsg cb), deserialize serialized_params =
                                                                            Some (@CIS1_receiver_receive_hook Msg sMsg _  p).</span></span></pre><div class="doc">
A specification for the batch transfer 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">transfer_spec</span> `{ChainBase}
         (params : CIS1_transfer_params)
         (prev_st next_st : Storage)
         (ret_ops : list ActionBody) : <span class="kt">Prop</span> :=
    {
      transfer_dec_inc :
        compose_transfers prev_st next_st params.(cis_tr_transfers)
                         (<span class="kr">fun</span> <span class="nv">st1</span> <span class="nv">st2</span> <span class="nv">x</span> <span class="nv">p</span> <span class="nv">q</span> =&gt;
                            transfer_single_spec
                              st1
                              st2
                              x.(cis1_td_token_id) p q
                              x.(cis1_td_from)
                              x.(cis1_td_to)
                                  x.(cis1_td_amount));

      <span class="sd">(** CIS1: A transfer of any amount of a token type to a contract address MUST call receive hook function on the receiving smart contract with a receive hook parameter. *)</span>
      transfer_receive_hook_calls :
      <span class="sd">(** We consider only transfers to addresses that are contracts *)</span>
      <span class="kr">let</span> <span class="nv">transfers_to_contracts</span> := filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; address_is_contract x.(cis1_td_to)) params.(cis_tr_transfers) <span class="kr">in</span>
      Forall (<span class="kr">fun</span> &#39;(op,(to_addr, params)) =&gt;
                <span class="kr">exists</span> <span class="nv">val</span>,
                  op = act_call to_addr <span class="mi">0</span>%Z val /\
                 is_valid_receive_hook params val)
             (combine ret_ops (get_receive_hook_params transfers_to_contracts)) /\
      ret_ops = map (<span class="kr">fun</span> &#39;(to_addr, params) =&gt; act_call to_addr <span class="mi">0</span> (serialize params))
                    (get_receive_hook_params transfers_to_contracts)
    }.</span></span></pre><div class="doc">
<a name="lab8"></a><h3 class="section">updateOperator</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
<a name="lab9"></a><h4 class="section">Parameter</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">CIS1_updateOperator_kind</span> :=
    cis1_ou_remove_operator
  | cis1_ou_add_operator.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_updateOperator_update</span> `{ChainBase} :=
    { cis1_ou_update_kind : CIS1_updateOperator_kind;
      cis1_ou_operator_address : Address }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_updateOperator_params</span> `{ChainBase} :=
    { cis1_ou_params : list CIS1_updateOperator_update }.</span></span></pre><div class="doc">
<a name="lab10"></a><h4 class="section">Requirements</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
A specification for the update of a single operator 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">updateOperator_single_spec</span>  `{ChainBase} (ctx : ContractCallContext) (prev_st next_st : Storage) (p : CIS1_updateOperator_update) : <span class="kt">Prop</span> :=
    <span class="kr">match</span> p.(cis1_ou_update_kind) <span class="kr">with</span>
    | cis1_ou_remove_operator =&gt;
      <span class="kr">let</span> <span class="nv">addr</span> := p.(cis1_ou_operator_address) <span class="kr">in</span>
      <span class="sd">(** All operators, apart from [addr] remain the same in both states *)</span>
      (<span class="kr">forall</span> <span class="nv">addr0</span>, addr0 &lt;&gt; addr -&gt;
                In addr0 (get_operators prev_st ctx.(ctx_from)) &lt;-&gt;
                In addr0 (get_operators next_st ctx.(ctx_from))) /\
      <span class="sd">(** An operator &quot;to remove&quot; is removed (not present) for the caller *)</span>
      ~ In addr (get_operators next_st ctx.(ctx_from))
    | cis1_ou_add_operator =&gt;
      <span class="kr">let</span> <span class="nv">addr</span> := p.(cis1_ou_operator_address) <span class="kr">in</span>
      <span class="sd">(** All operators, apart from [addr] remain the same in both states *)</span>
      (<span class="kr">forall</span> <span class="nv">addr0</span>, addr0 &lt;&gt; addr -&gt;
                In addr0 (get_operators prev_st ctx.(ctx_from)) &lt;-&gt;
                In addr0 (get_operators next_st ctx.(ctx_from))) /\
      <span class="c">(* an operator &quot;to add&quot; is recorded for the caller *)</span>
      In addr (get_operators next_st ctx.(ctx_from))
    <span class="kr">end</span>.</span></span></pre><div class="doc">
CIS1: The list of updates MUST be executed in order. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">compose_uptadeOperator_specs</span> `{ChainBase} (ctx : ContractCallContext) (st final_st : Storage) (updates : list CIS1_updateOperator_update) :=
    <span class="kr">match</span> updates <span class="kr">with</span>
    | [] =&gt; st = final_st
    | p :: ps =&gt; <span class="kr">exists</span> <span class="nv">next_st</span>, updateOperator_single_spec ctx st next_st p /\
                     compose_uptadeOperator_specs ctx next_st final_st ps
    <span class="kr">end</span>.</span></span></pre><div class="doc">
A specification of the batch operatior update 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">updateOperator_spec</span> `{ChainBase}
         (ctx : ContractCallContext)
         (params : CIS1_updateOperator_params)
         (prev_st next_st : Storage)
         (ret_ops : list ActionBody) :=
    { updateOperator_token_ids_preserved :
        <span class="kr">forall</span> <span class="nv">token_id</span>,
          token_id_exists prev_st token_id =  token_id_exists next_st token_id;

      updateOperator_balances_preserved : <span class="kr">forall</span> <span class="nv">addr</span> <span class="nv">token_id</span>,
        get_balance_opt prev_st token_id addr = get_balance_opt next_st token_id addr;

      updateOperator_add_remove :
        compose_uptadeOperator_specs ctx prev_st next_st params.(cis1_ou_params)
    }.</span></span></pre><div class="doc">
<a name="lab11"></a><h3 class="section">balanceOf</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
<a name="lab12"></a><h4 class="section">Parameter</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_balanceOf_query</span> `{ChainBase} :=
    { cis1_bo_query_token_id : TokenID;
      cis1_bo_query_address  : Address }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CIS1_balanceOf_params</span> `{ChainBase} :=
    { cis1_bo_query : list CIS1_balanceOf_query;
      cis1_bo_result_address : Address;
      cis1_bo_result_address_is_contract : address_is_contract cis1_bo_result_address = true}.</span></span></pre><div class="doc">
CIS1: The parameter for the callback receive function is a list of pairs, where each pair is a query and an amount of tokens.
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">balanceOf_callback_type</span> `{ChainBase} : <span class="kt">Type</span> := list (TokenID * Address * TokenAmount).</span></span></pre><div class="doc">
<a name="lab13"></a><h4 class="section">Requirements</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
CIS1: The contract function MUST reject if any of the queries fail.

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" title="var">get_balance</span></span> function returns <span class="inlinecode"><span class="id" title="var">None</span></span> (fails) if the token id is unknown.
  We combine the calls to <span class="inlinecode"><span class="id" title="var">get_balance</span></span> using <span class="inlinecode"><span class="id" title="var">monad_map</span></span> where the monad is the <span class="inlinecode"><span class="id" title="var">option</span></span> monad.
   
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_balances</span> `{ChainBase} (st : Storage) (params : CIS1_balanceOf_params) : option balanceOf_callback_type :=
    monad_map
      (<span class="kr">fun</span> <span class="nv">q</span> =&gt;
         <span class="kr">let</span> <span class="nv">addr</span> := q.(cis1_bo_query_address) <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">token_id</span> := q.(cis1_bo_query_token_id) <span class="kr">in</span>
         balance &lt;- get_balance st token_id addr;;
         Some (token_id, addr, balance)) params.(cis1_bo_query).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">balanceOf_spec</span>
         `{ChainBase}
         (params : CIS1_balanceOf_params)
         (prev_st next_st : Storage)
         (ret_ops : list ActionBody) : <span class="kt">Prop</span> :=
    { balanceOf_operators_preserved:
      <span class="kr">forall</span> <span class="nv">addr</span>, get_operators next_st addr = get_operators prev_st addr;

      balanceOf_token_ids_preserved :
        <span class="kr">forall</span> <span class="nv">token_id</span>,
          token_id_exists prev_st token_id =  token_id_exists next_st token_id;

      balanceOf_balances_preserved :
        <span class="kr">forall</span> <span class="nv">token_id</span> <span class="nv">addr</span>, get_balance_opt next_st token_id addr = get_balance_opt prev_st token_id addr;

     <span class="sd">(** NOTE: It&#39;s assumed that the receiving contract accepts messages of type [balanceOf_callback_type] *)</span>
      balanceOf_callback :
      <span class="kr">match</span> get_balances prev_st params <span class="kr">with</span>
        | Some query_results =&gt;
          <span class="kr">let</span> <span class="nv">serialized_query_results</span> := serialize query_results <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">op</span> := act_call params.(cis1_bo_result_address) <span class="mi">0</span>%Z serialized_query_results <span class="kr">in</span>
          ret_ops = [op]
        | None =&gt; <span class="kt">False</span>
        <span class="kr">end</span>
    }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CIS1Axioms</span>.</span></span></pre><div class="doc">
<a name="lab14"></a><h2 class="section">CIS1 properties</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a name="lab15"></a><h3 class="section">Operator updates</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">CIS1Operators</span> (cis1_types : CIS1Types) (cis1_view : CIS1View cis1_types)
       (cis1_axioms : CIS1Axioms cis1_types cis1_view).</span></span></pre><div class="doc">
Sanity checks for the batch operator update spec 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> cis1_types cis1_view cis1_axioms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk0"><span class="kn">Lemma</span> <span class="nf">compose_updateOperator_add_add</span> :
    <span class="kr">forall</span> `{ChainBase} (ctx : ContractCallContext)
           (prev_st : Storage) (next_st : Storage) (addr1 addr2 : Address),
      <span class="kr">let</span> <span class="nv">add_addr1</span> := {| cis1_ou_update_kind := cis1_ou_add_operator;
                         cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">add_addr2</span> := {| cis1_ou_update_kind := cis1_ou_add_operator;
                            cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
      compose_uptadeOperator_specs ctx prev_st next_st [add_addr1; add_addr2] -&gt;
      In addr1 (get_operators next_st ctx.(ctx_from)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr1</span> <span class="nv">addr2</span> : Address),
<span class="kr">let</span> <span class="nv">add_addr1</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">add_addr2</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr1; add_addr2] -&gt;
In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr1</span> <span class="nv">addr2</span> : Address),
<span class="kr">let</span> <span class="nv">add_addr1</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">add_addr2</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr1; add_addr2] -&gt;
In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2"><span class="nb">intros</span> ? ? ? ? ? ? ? ? H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr1; add_addr2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">next_st0</span> : Storage,
  updateOperator_single_spec ctx prev_st next_st0
    add_addr1 /\
  (<span class="kr">exists</span> <span class="nv">next_st1</span> : Storage,
     updateOperator_single_spec ctx next_st0
       next_st1 add_addr2 /\ 
     next_st1 = next_st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4"><span class="nb">destruct</span> H <span class="kr">as</span> [st1 [Hst1 [st2 [Hst2 Heq]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  add_addr1</span></span></span><br><span><var>st2</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 st2
  add_addr2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>st2 = next_st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  add_addr1</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 next_st
  add_addr2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr1 -&gt;
 In addr0
   (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
 In addr0 (get_operators st1 (ctx_from ctx))) /\
In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr2 -&gt;
 In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
 In addr0
   (get_operators next_st (ctx_from ctx))) /\
In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7"><span class="nb">destruct</span> Hst1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr2 -&gt;
 In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
 In addr0
   (get_operators next_st (ctx_from ctx))) /\
In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8"><span class="nb">destruct</span> Hst2 <span class="kr">as</span> [H2 ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr2 -&gt;
In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9"><span class="nb">destruct</span> (address_eqb_spec addr1 addr2);<span class="nb">subst</span>;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr1</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr2</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr2 -&gt;
In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H2;<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka"><span class="kn">Lemma</span> <span class="nf">compose_updateOperator_add_remove_same</span> :
    <span class="kr">forall</span> `{ChainBase} (ctx : ContractCallContext)
      (prev_st : Storage) (next_st : Storage) (addr : Address),
      <span class="kr">let</span> <span class="nv">add_addr</span> := {| cis1_ou_update_kind := cis1_ou_add_operator;
                         cis1_ou_operator_address := addr |} <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">remove_addr</span> := {| cis1_ou_update_kind := cis1_ou_remove_operator;
                            cis1_ou_operator_address := addr |} <span class="kr">in</span>
      compose_uptadeOperator_specs ctx prev_st next_st [add_addr; remove_addr] -&gt;
      ~ In addr (get_operators next_st ctx.(ctx_from)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr</span> : Address),
<span class="kr">let</span> <span class="nv">add_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">remove_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_remove_operator;
  cis1_ou_operator_address := addr |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr; remove_addr] -&gt;
~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr</span> : Address),
<span class="kr">let</span> <span class="nv">add_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">remove_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_remove_operator;
  cis1_ou_operator_address := addr |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr; remove_addr] -&gt;
~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc"><span class="nb">intros</span> ? ? ? ? ? ? ? H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  [add_addr; remove_addr]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">next_st0</span> : Storage,
  updateOperator_single_spec ctx prev_st next_st0
    add_addr /\
  (<span class="kr">exists</span> <span class="nv">next_st1</span> : Storage,
     updateOperator_single_spec ctx next_st0
       next_st1 remove_addr /\ 
     next_st1 = next_st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke"><span class="nb">destruct</span> H <span class="kr">as</span> [st1 [Hst1 [st2 [Hst2 Heq]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  add_addr</span></span></span><br><span><var>st2</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 st2
  remove_addr</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>st2 = next_st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  add_addr</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 next_st
  remove_addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr -&gt;
 In addr0
   (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
 In addr0 (get_operators st1 (ctx_from ctx))) /\
In addr (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr -&gt;
 In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
 In addr0
   (get_operators next_st (ctx_from ctx))) /\
~
In addr (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11"><span class="nb">destruct</span> Hst2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr -&gt;
 In addr0
   (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
 In addr0 (get_operators st1 (ctx_from ctx))) /\
In addr (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr -&gt;
In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ In addr (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk12"><span class="kn">Lemma</span> <span class="nf">compose_updateOperator_remove_one_remove_another</span> :
    <span class="kr">forall</span> `{ChainBase} (ctx : ContractCallContext)
      (prev_st : Storage) (next_st : Storage) (addr1 addr2 : Address),
      addr1 &lt;&gt; addr2 -&gt;
      <span class="kr">let</span> <span class="nv">remove_addr</span> := {| cis1_ou_update_kind := cis1_ou_remove_operator;
                            cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">add_addr</span> := {| cis1_ou_update_kind := cis1_ou_add_operator;
                         cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
      compose_uptadeOperator_specs ctx prev_st next_st [remove_addr; add_addr] -&gt;
      ~ In addr1 (get_operators next_st ctx.(ctx_from)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr1</span> <span class="nv">addr2</span> : Address),
addr1 &lt;&gt; addr2 -&gt;
<span class="kr">let</span> <span class="nv">remove_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_remove_operator;
  cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">add_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [remove_addr; add_addr] -&gt;
~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">H</span> : ChainBase) (<span class="nv">ctx</span> : ContractCallContext)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage) (<span class="nv">addr1</span> <span class="nv">addr2</span> : Address),
addr1 &lt;&gt; addr2 -&gt;
<span class="kr">let</span> <span class="nv">remove_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_remove_operator;
  cis1_ou_operator_address := addr1 |} <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">add_addr</span> :=
  {|
  cis1_ou_update_kind := cis1_ou_add_operator;
  cis1_ou_operator_address := addr2 |} <span class="kr">in</span>
compose_uptadeOperator_specs ctx prev_st next_st
  [remove_addr; add_addr] -&gt;
~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk14"><span class="nb">intros</span> ? ? ? ? ? ? Hneq ? ? H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  [remove_addr; add_addr]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">next_st0</span> : Storage,
  updateOperator_single_spec ctx prev_st next_st0
    remove_addr /\
  (<span class="kr">exists</span> <span class="nv">next_st1</span> : Storage,
     updateOperator_single_spec ctx next_st0
       next_st1 add_addr /\ 
     next_st1 = next_st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16"><span class="nb">destruct</span> H <span class="kr">as</span> [st1 [Hst1 [st2 [Hst2 Heq]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  remove_addr</span></span></span><br><span><var>st2</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 st2 add_addr</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>st2 = next_st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk17"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx prev_st st1
  remove_addr</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>updateOperator_single_spec ctx st1 next_st
  add_addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk18"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hst1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr1 -&gt;
 In addr0
   (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
 In addr0 (get_operators st1 (ctx_from ctx))) /\
~ In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr2 -&gt;
 In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
 In addr0
   (get_operators next_st (ctx_from ctx))) /\
In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk19"><span class="nb">destruct</span> Hst1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>Hst2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 addr0 &lt;&gt; addr2 -&gt;
 In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
 In addr0
   (get_operators next_st (ctx_from ctx))) /\
In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1a"><span class="nb">destruct</span> Hst2 <span class="kr">as</span> [H2 ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr2 -&gt;
In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr1 (get_operators next_st (ctx_from ctx))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1b"><span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr2 -&gt;
In addr0 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1c"><span class="nb">specialize</span> (H2 _ Hneq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H0</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1, addr2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>addr1 &lt;&gt; addr2</span></span></span><br><span><var>remove_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_remove_operator;
cis1_ou_operator_address := addr1 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>add_addr</var><span><span class="hyp-body"><b>:= </b><span>{|
cis1_ou_update_kind := cis1_ou_add_operator;
cis1_ou_operator_address := addr2 |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_update</span></span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; addr1 -&gt;
In addr0 (get_operators prev_st (ctx_from ctx)) &lt;-&gt;
In addr0 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>~ In addr1 (get_operators st1 (ctx_from ctx))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators st1 (ctx_from ctx)) &lt;-&gt;
In addr1 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr2 (get_operators next_st (ctx_from ctx))</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>In addr1 (get_operators next_st (ctx_from ctx))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_operator_remove</span> `{ChainBase} (up : CIS1_updateOperator_update) : bool :=
    <span class="kr">match</span> up.(cis1_ou_update_kind) <span class="kr">with</span>
    | cis1_ou_remove_operator =&gt; true
    | _ =&gt; false
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_operator_add</span> `{ChainBase} (up : CIS1_updateOperator_update) : bool :=
    <span class="kr">match</span> up.(cis1_ou_update_kind) <span class="kr">with</span>
    | cis1_ou_add_operator =&gt; true
    | _ =&gt; false
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> bool_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_for_address</span> `{ChainBase} (addr : Address) (up : CIS1_updateOperator_update) : bool :=
    address_eqb up.(cis1_ou_operator_address) addr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">count_removes</span> `{ChainBase} (addr : Address) (updates : list CIS1_updateOperator_update) : nat :=
    length (filter (<span class="kr">fun</span> <span class="nv">up</span> =&gt; is_operator_remove up &amp;&amp; is_for_address addr up) updates).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">count_adds</span> `{ChainBase} (addr : Address) (updates : list CIS1_updateOperator_update) : nat :=
    length (filter (<span class="kr">fun</span> <span class="nv">up</span> =&gt; is_operator_add up &amp;&amp; is_for_address addr up) updates).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Lemma compose_updateOperator_remove_one_no_add : *)</span>
  <span class="c">(*   forall `{ChainBase} *)</span>
  <span class="c">(*     (updates : list CIS1_updateOperator_update) *)</span>
  <span class="c">(*     (ctx : ContractCallContext) *)</span>
  <span class="c">(*     (prev_st : Storage) (next_st : Storage) (addr: Address), *)</span>
  <span class="c">(*     count_removes addr updates &gt; count_adds addr updates -&gt; *)</span>
  <span class="c">(*     compose_uptadeOperator_specs ctx prev_st next_st updates -&gt; *)</span>
  <span class="c">(*     ~ In addr (get_operators next_st ctx.(ctx_from)). *)</span>
  <span class="c">(*  Proof. *)</span>
  <span class="c">(*    induction updates. *)</span>
  <span class="c">(*    + easy. *)</span>
  <span class="c">(*    + intros ctx prev_st next_st addr Hgt spec. cbn in *. *)</span>
  <span class="c">(*      destruct (is_operator_remove a &amp;&amp; is_for_address addr a) eqn:Hremove; *)</span>
  <span class="c">(*        destruct (is_operator_add a &amp;&amp; is_for_address addr a) eqn:Hadd. *)</span>
  <span class="c">(*      * apply andb_prop in Hremove. cbn in Hremove. *)</span>
  <span class="c">(*        apply andb_prop in Hadd. cbn in Hadd. *)</span>
  <span class="c">(*        destruct a as [k a];destruct k;cbn in *;intuition. *)</span>
  <span class="c">(*      * apply andb_prop in Hremove. cbn in Hremove. *)</span>
  <span class="c">(*        unfold is_operator_remove in Hremove. *)</span>
  <span class="c">(*        destruct Hremove. *)</span>
  <span class="c">(*        destruct spec as [st1 [Hst1 Hrest]]. *)</span>
  <span class="c">(*        unfold updateOperator_single_spec in *. *)</span>
  <span class="c">(*        destruct (cis1_ou_update_kind a);try easy. *)</span>
  <span class="c">(*        intros ?. *)</span>
  <span class="c">(*        apply Hst1. *)</span>
  <span class="c">(*    destruct spec as [st1 [Hst1 [st2 [Hst2 Heq]]]]. subst. cbn in *. *)</span>
  <span class="c">(*    destruct Hst1. destruct Hst2 as [H2 ?]. *)</span>
  <span class="c">(*    intro. specialize (H2 _ Hneq). easy. *)</span>
  <span class="c">(*  Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CIS1Operators</span>.</span></span></pre><div class="doc">
<a name="lab16"></a><h3 class="section">Balances</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">CIS1Balances</span> (cis1_types : CIS1Types) (cis1_view : CIS1View cis1_types)
       (cis1_axioms : CIS1Axioms cis1_types cis1_view).</span></span></pre><div class="doc">
In this module we prove properties related to the preservation of the sum of all balances for
      all token ids.

<div class="paragraph"> </div>

      These properties follow directly from the specification. That means, in particular, that all
      the contracts that satisfy the specification will automatically satisfy all the properties we
      prove here. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> cis1_types cis1_view cis1_axioms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* begin hide *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">addr_eq_dec</span> `{ChainBase} (a1 a2 : Address) : {a1 = a2} + {a1 &lt;&gt; a2} :=
    <span class="kr">match</span> address_eqb_spec a1 a2 <span class="kr">with</span>
    | ssrbool.ReflectT _ p =&gt; <span class="nb">left</span> p
    | ssrbool.ReflectF _ p =&gt; <span class="nb">right</span> p
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* end hide *)</span></span></pre><div class="doc">
Get the balance and return zero if <span class="inlinecode"><span class="id" title="var">get_balance</span></span> returns <span class="inlinecode"><span class="id" title="var">None</span></span>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_balance_default</span> `{ChainBase} : Storage -&gt; TokenID -&gt; Address -&gt; TokenAmount :=
    <span class="kr">fun</span> <span class="nv">st</span> <span class="nv">token_id</span> <span class="nv">addr</span> =&gt; <span class="kr">match</span> get_balance st token_id addr <span class="kr">with</span>
                         | Some amount =&gt; amount
                         | None =&gt; <span class="mi">0</span>
                         <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sum_balances</span> `{ChainBase} (st : Storage) (token_id : TokenID) (owners : list Address) :=
    fold_right (<span class="kr">fun</span> <span class="nv">addr</span> <span class="nv">s</span> =&gt; get_balance_default st token_id addr + s) <span class="mi">0</span> owners.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1d"><span class="kn">Lemma</span> <span class="nf">remove_owner</span> `{ChainBase} st token_id (owners : list Address) (owner : Address) :
    In owner owners \/ get_balance_default st token_id owner = <span class="mi">0</span> -&gt;
    NoDup owners -&gt;
    sum_balances st token_id owners = get_balance_default st token_id owner + sum_balances st token_id (remove addr_eq_dec owner owners).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner owners \/
get_balance_default st token_id owner = <span class="mi">0</span> -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner owners \/
get_balance_default st token_id owner = <span class="mi">0</span> -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk1f"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner owners \/
get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk20"><span class="nb">destruct</span> Hin <span class="kr">as</span> [Hin | Hbal].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk21"><hr></label><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk22"><span class="nb">revert dependent</span> owner.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">owner</span> : Address,
In owner owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk23"><hr></label><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">owner</span> : Address,
In owner owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk25"><span class="nb">induction</span> owners;<span class="nb">intros</span> owner Hin Hnodup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner []</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id [] =
get_balance_default st token_id owner +
sum_balances st token_id (remove addr_eq_dec owner [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner (a :: owners)</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk26"><hr></label><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk27">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner []</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id [] =
get_balance_default st token_id owner +
sum_balances st token_id (remove addr_eq_dec owner [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk28">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In owner (a :: owners)</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk29"><span class="nb">inversion</span> Hin;<span class="nb">subst</span>;<span class="nb">clear</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (owner :: owners)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (owner :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (owner :: owners))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk2a"><hr></label><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (owner :: owners)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (owner :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (owner :: owners))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (owner :: owners)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id owner +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (<span class="kr">if</span> addr_eq_dec owner owner
   <span class="kr">then</span> remove addr_eq_dec owner owners
   <span class="kr">else</span> owner :: remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2d"><span class="nb">destruct</span> (addr_eq_dec owner owner);<span class="kp">try</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (owner :: owners)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>owner = owner</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id owner +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2e"><span class="nb">inversion</span> Hnodup;<span class="nb">subst</span>;<span class="nb">clear</span> Hnodup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>owner = owner</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>~ In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id owner +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> not_in_remove_same.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk2f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk30"><span class="nb">inversion</span> Hnodup;<span class="nb">subst</span>;<span class="nb">clear</span> Hnodup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk31"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (<span class="kr">if</span> addr_eq_dec owner a
   <span class="kr">then</span> remove addr_eq_dec owner owners
   <span class="kr">else</span> a :: remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk32"><span class="nb">destruct</span> (addr_eq_dec owner a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>owner = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>owner &lt;&gt; a</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk33"><hr></label><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (a :: remove addr_eq_dec owner owners)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk34">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>owner = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk35">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>owner &lt;&gt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (a :: remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk36"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">owner0</span> : Address,
In owner0 owners -&gt;
NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner0 +
sum_balances st token_id
  (remove addr_eq_dec owner0 owners)</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>owner &lt;&gt; a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
get_balance_default st token_id owner +
(get_balance_default st token_id a +
 sum_balances st token_id
   (remove addr_eq_dec owner owners))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (IHowners owner);<span class="nb">auto</span>;<span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
get_balance_default st token_id owner +
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk38"><span class="nb">rewrite</span> Hbal;<span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners -&gt;
sum_balances st token_id owners =
sum_balances st token_id
  (remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk39"><span class="nb">induction</span> owners; <span class="nb">intros</span> Hnodup;<span class="nb">auto</span>;<span class="nb">inversion</span> Hnodup;<span class="nb">subst</span>;<span class="nb">clear</span> Hnodup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span>NoDup owners -&gt;
sum_balances st token_id owners =
sum_balances st token_id
  (remove addr_eq_dec owner owners)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (a :: owners) =
sum_balances st token_id
  (remove addr_eq_dec owner (a :: owners))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span>get_balance_default st token_id owner = <span class="mi">0</span></span></span></span><br><span><var>IHowners</var><span class="hyp-type"><b>: </b><span>NoDup owners -&gt;
sum_balances st token_id owners =
sum_balances st token_id
  (remove addr_eq_dec owner owners)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>~ In a owners</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>NoDup owners</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners =
sum_balances st token_id
  (<span class="kr">if</span> addr_eq_dec owner a
   <span class="kr">then</span> remove addr_eq_dec owner owners
   <span class="kr">else</span> a :: remove addr_eq_dec owner owners)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (addr_eq_dec owner a);<span class="nb">subst</span>;<span class="nb">simpl</span>;<span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3b"><span class="kn">Lemma</span> <span class="nf">sum_of_other_balances_eq</span> `{ChainBase} <span class="kn">from</span> to addrs prev_st next_st token_id :
    (<span class="kr">forall</span> <span class="nv">addr</span>, addr &lt;&gt; <span class="kn">from</span> -&gt; addr &lt;&gt; to -&gt; get_balance_default next_st token_id addr = get_balance_default prev_st token_id addr) -&gt;
    ~ In <span class="kn">from</span> addrs -&gt;
    ~ In to addrs -&gt;
    sum_balances next_st token_id addrs = sum_balances prev_st token_id addrs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 addr &lt;&gt; <span class="kn">from</span> -&gt;
 addr &lt;&gt; to -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
~ In <span class="kn">from</span> addrs -&gt;
~ In to addrs -&gt;
sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 addr &lt;&gt; <span class="kn">from</span> -&gt;
 addr &lt;&gt; to -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
~ In <span class="kn">from</span> addrs -&gt;
~ In to addrs -&gt;
sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3d"><span class="nb">intros</span> Hbal Hform Hto.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</span></span></span><br><span><var>Hform</var><span class="hyp-type"><b>: </b><span>~ In <span class="kn">from</span> addrs</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In to addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> addrs;<span class="nb">simpl</span> <span class="kr">in</span> *;<span class="nb">intuition</span>;<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3e"><span class="kn">Lemma</span> <span class="nf">sum_of_balances_eq</span> `{ChainBase} addrs prev_st next_st token_id :
    (<span class="kr">forall</span> <span class="nv">addr</span>, In addr addrs -&gt;get_balance_default next_st token_id addr = get_balance_default prev_st token_id addr) -&gt;
    sum_balances next_st token_id addrs = sum_balances prev_st token_id addrs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr addrs -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr addrs -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk40"><span class="nb">intros</span> Hbal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hbal</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr addrs -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id addrs =
sum_balances prev_st token_id addrs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> addrs;<span class="nb">simpl</span> <span class="kr">in</span> *;<span class="nb">intuition</span>;<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> remove_In not_in_remove_same not_in_remove remove_remove neq_not_removed : hints.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> remove_extensional : hints.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk41"><span class="kn">Lemma</span> <span class="nf">sum_balances_extensional</span> `{ChainBase} st token_id owners1 owners2 :
    NoDup owners1 -&gt;
    NoDup owners2 -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, In addr owners1 &lt;-&gt; In addr owners2) -&gt;
    sum_balances st token_id owners1 = sum_balances st token_id owners2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners1 -&gt;
NoDup owners2 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners2) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners1 -&gt;
NoDup owners2 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners2) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk43"><span class="nb">intros</span> Hnodup1 Hnodup2 Hiff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk44"><span class="nb">revert dependent</span> owners2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">owners2</span> : list Address,
NoDup owners2 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners2) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk45"><span class="nb">induction</span> owners1;<span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr [] &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id [] =
sum_balances st token_id owners2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (a :: owners1) &lt;-&gt; In addr owners2</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk46"><hr></label><div class="goal-conclusion">sum_balances st token_id (a :: owners1) =
sum_balances st token_id owners2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk47">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr [] &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id [] =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk48"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
<span class="kt">False</span> &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk49"><span class="nb">destruct</span> owners2;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners2)</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
<span class="kt">False</span> &lt;-&gt; In addr (a :: owners2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = sum_balances st token_id (a :: owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Hiff a);<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (a :: owners1) &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (a :: owners1) =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (a :: owners1) &lt;-&gt; In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4c"><span class="nb">destruct</span> (Hiff a) <span class="kr">as</span> [H1 H2];<span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
a = addr \/ In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4d"><span class="nb">specialize</span> (H1 (or_introl eq_refl)) <span class="kr">as</span> HH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
a = addr \/ In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners1 =
sum_balances st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4e"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st0 := st) (owner := a) (owners:=owners2);<span class="nb">auto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
a = addr \/ In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners1 =
get_balance_default st token_id a +
sum_balances st token_id
  (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk4f"><span class="nb">inversion</span> Hnodup1;<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
a = addr \/ In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id a +
sum_balances st token_id owners1 =
get_balance_default st token_id a +
sum_balances st token_id
  (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk50"><span class="nb">rewrite</span> IHowners1 <span class="kr">with</span> (owners2 := (remove addr_eq_dec a owners2));<span class="nb">eauto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
a = addr \/ In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 &lt;-&gt;
In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk51"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1 &lt;-&gt;
In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk52"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1 -&gt;
In addr (remove addr_eq_dec a owners2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk53"><hr></label><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2) -&gt;
In addr owners1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk54">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1 -&gt;
In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk55"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk56"><span class="nb">destruct</span> (Hiff addr) <span class="kr">as</span> [HH1 HH2];<span class="nb">cbn</span> <span class="kr">in</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk57"><span class="nb">specialize</span> (HH1 (or_intror Hin)) <span class="kr">as</span> HH1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk58"><span class="nb">destruct</span> (address_eqb_spec a addr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk59"><hr></label><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5a">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5b">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr owners1</span></span></span><br><span><var>HH2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>HH1</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> hints.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (remove addr_eq_dec a owners2) -&gt;
In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5d"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5e"><span class="nb">destruct</span> (Hiff addr);<span class="nb">cbn</span> <span class="kr">in</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk5f"><span class="nb">destruct</span> (address_eqb_spec a addr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk60"><hr></label><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk61">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk62"><span class="nb">assert</span> (~ In addr (remove addr_eq_dec a owners2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (remove addr_eq_dec a owners2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>~ In addr (remove addr_eq_dec a owners2)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk63"><hr></label><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk64">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ In addr (remove addr_eq_dec a owners2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk65"><span class="nb">intros</span> Hin0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br><span><var>Hin0</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk66"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; addr = addr \/ In addr owners1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>addr = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec addr owners2)</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (addr :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In addr owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; addr = addr \/ In addr owners1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>addr = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>Hin0</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec addr owners2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (remove_In _ _ _ Hin0).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk67">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a = addr</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>~ In addr (remove addr_eq_dec a owners2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk68">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk69"><span class="nb">assert</span> (In addr owners2) <span class="bp">by</span> <span class="nb">eauto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>owners1</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup1</var><span class="hyp-type"><b>: </b><span>NoDup (a :: owners1)</span></span></span><br><span><var>IHowners1</var><span class="hyp-type"><b>: </b><span>NoDup owners1 -&gt;
<span class="kr">forall</span> <span class="nv">owners0</span> : list Address,
NoDup owners0 -&gt;
(<span class="kr">forall</span> <span class="nv">addr0</span> : Address,
 In addr0 owners1 &lt;-&gt; In addr0 owners0) -&gt;
sum_balances st token_id owners1 =
sum_balances st token_id owners0</span></span></span><br><span><var>owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>Hnodup2</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>Hiff</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
a = addr0 \/ In addr0 owners1 &lt;-&gt;
In addr0 owners2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a = a \/ In a owners1 -&gt; In a owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>In a owners2 -&gt; a = a \/ In a owners1</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>In a owners2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>~ In a owners1</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (remove addr_eq_dec a owners2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a = addr \/ In addr owners1 -&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr owners2 -&gt; a = addr \/ In addr owners1</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a &lt;&gt; addr</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>In addr owners2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6a"><span class="kn">Lemma</span> <span class="nf">sum_of_balances_eq_extensional</span> `{ChainBase} owners1 owners2 prev_st next_st token_id :
    NoDup owners1 -&gt;
    NoDup owners2 -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, In addr owners1 &lt;-&gt; In addr owners2) -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, In addr owners1 -&gt; get_balance_default next_st token_id addr = get_balance_default prev_st token_id addr) -&gt;
    sum_balances next_st token_id owners1 = sum_balances prev_st token_id owners2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners1 -&gt;
NoDup owners2 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners2) -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
sum_balances next_st token_id owners1 =
sum_balances prev_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup owners1 -&gt;
NoDup owners2 -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 &lt;-&gt; In addr owners2) -&gt;
(<span class="kr">forall</span> <span class="nv">addr</span> : Address,
 In addr owners1 -&gt;
 get_balance_default next_st token_id addr =
 get_balance_default prev_st token_id addr) -&gt;
sum_balances next_st token_id owners1 =
sum_balances prev_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners1 =
sum_balances prev_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6d"><span class="nb">erewrite</span> sum_of_balances_eq <span class="bp">by</span> <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>owners1, owners2</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>NoDup owners1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>NoDup owners2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 &lt;-&gt; In addr owners2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr owners1 -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances prev_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sum_balances_extensional;<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6e"><span class="kn">Lemma</span> <span class="nf">same_owners</span> `{ChainBase}  token_id addr next_st prev_st :
    get_balance_opt next_st token_id addr = get_balance_opt prev_st token_id addr -&gt;
    In addr (get_owners next_st token_id) &lt;-&gt; In addr (get_owners prev_st token_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk70"><span class="nb">intros</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk71"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id) -&gt;
In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk72"><hr></label><div class="goal-conclusion">In addr (get_owners prev_st token_id) -&gt;
In addr (get_owners next_st token_id)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk73">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id) -&gt;
In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk74"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk75"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr) <span class="nb">eqn</span>:Hnext;<span class="nb">inversion</span> Hnext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk76"><hr></label><div class="goal-conclusion">In addr (get_owners prev_st token_id)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk77">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk78">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances <span class="kr">in</span> Hin;<span class="nb">destruct</span> Hin;<span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk79">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id) -&gt;
In addr (get_owners next_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7a"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7b"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr) <span class="nb">eqn</span>:Hnext;<span class="nb">inversion</span> Hnext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk7c"><hr></label><div class="goal-conclusion">In addr (get_owners next_st token_id)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances <span class="kr">in</span> Hin;<span class="nb">destruct</span> Hin;<span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk7f"><span class="kn">Lemma</span> <span class="nf">get_balance_opt_total</span> `{ChainBase} next_st prev_st token_id p q addr :
    get_balance_opt next_st token_id addr = get_balance_opt prev_st token_id addr -&gt;
    get_balance_total next_st token_id q addr = get_balance_total prev_st token_id p addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
get_balance_total next_st token_id q addr =
get_balance_total prev_st token_id p addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
get_balance_total next_st token_id q addr =
get_balance_total prev_st token_id p addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk81"><span class="nb">intros</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total next_st token_id q addr =
get_balance_total prev_st token_id p addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk82"><span class="nb">unfold</span> get_balance_total,get_balance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists next_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None) <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     (<span class="kr">if</span> token_id_exists next_st token_id
      <span class="kr">then</span>
       <span class="kr">match</span>
         get_balance_opt next_st token_id addr
       <span class="kr">with</span>
       | Some bal =&gt; Some bal
       | None =&gt; Some <span class="mi">0</span>
       <span class="kr">end</span>
      <span class="kr">else</span> None) -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          (<span class="kr">if</span> token_id_exists next_st token_id
           <span class="kr">then</span>
            <span class="kr">match</span>
              get_balance_opt next_st token_id addr
            <span class="kr">with</span>
            | Some bal0 =&gt; Some bal0
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span>
           <span class="kr">else</span> None) =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            (<span class="kr">if</span> token_id_exists next_st token_id
             <span class="kr">then</span>
              <span class="kr">match</span>
                get_balance_opt next_st token_id addr
              <span class="kr">with</span>
              | Some bal =&gt; Some bal
              | None =&gt; Some <span class="mi">0</span>
              <span class="kr">end</span>
             <span class="kr">else</span> None) =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt next_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind (token_id_exists next_st token_id)
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt next_st token_id addr
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true q))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists prev_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None) <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     (<span class="kr">if</span> token_id_exists prev_st token_id
      <span class="kr">then</span>
       <span class="kr">match</span>
         get_balance_opt prev_st token_id addr
       <span class="kr">with</span>
       | Some bal =&gt; Some bal
       | None =&gt; Some <span class="mi">0</span>
       <span class="kr">end</span>
      <span class="kr">else</span> None) -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          (<span class="kr">if</span> token_id_exists prev_st token_id
           <span class="kr">then</span>
            <span class="kr">match</span>
              get_balance_opt prev_st token_id addr
            <span class="kr">with</span>
            | Some bal0 =&gt; Some bal0
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span>
           <span class="kr">else</span> None) =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            (<span class="kr">if</span> token_id_exists prev_st token_id
             <span class="kr">then</span>
              <span class="kr">match</span>
                get_balance_opt prev_st token_id addr
              <span class="kr">with</span>
              | Some bal =&gt; Some bal
              | None =&gt; Some <span class="mi">0</span>
              <span class="kr">end</span>
             <span class="kr">else</span> None) =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt prev_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind (token_id_exists prev_st token_id)
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt prev_st token_id addr
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true p))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk83"><span class="nb">rewrite</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span>
            get_balance_opt next_st token_id addr
          <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt next_st token_id addr
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt next_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind true
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt next_st token_id addr
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true eq_refl))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span>
            get_balance_opt prev_st token_id addr
          <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt prev_st token_id addr
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt prev_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind true
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt prev_st token_id addr
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true eq_refl))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk84"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span>
            get_balance_opt next_st token_id addr
          <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt next_st token_id addr
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt next_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span> heq)
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span>
            get_balance_opt prev_st token_id addr
          <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt prev_st token_id addr
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt prev_st token_id addr <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span> heq)
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr) <span class="nb">eqn</span>:Heq1;
    <span class="nb">destruct</span> (get_balance_opt prev_st token_id addr) <span class="nb">eqn</span>:Heq2;<span class="nb">auto</span>;
      <span class="nb">inversion</span> H;<span class="kp">try</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk85"><span class="kn">Lemma</span> <span class="nf">get_balance_opt_default</span> `{ChainBase} next_st prev_st token_id addr :
    token_id_exists prev_st token_id = token_id_exists next_st token_id -&gt;
    get_balance_opt next_st token_id addr = get_balance_opt prev_st token_id addr -&gt;
    get_balance_default next_st token_id addr = get_balance_default prev_st token_id addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id -&gt;
get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id -&gt;
get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk87"><span class="nb">intros</span> Hids Hopt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hids</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id =
token_id_exists next_st token_id</span></span></span><br><span><var>Hopt</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk88"><span class="nb">unfold</span> get_balance_default,get_balance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hids</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id =
token_id_exists next_st token_id</span></span></span><br><span><var>Hopt</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists next_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> =
<span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists prev_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk89"><span class="nb">rewrite</span> Hids.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hids</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id =
token_id_exists next_st token_id</span></span></span><br><span><var>Hopt</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists next_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> =
<span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists next_st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8a"><span class="nb">destruct</span> (token_id_exists next_st token_id);<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hids</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>Hopt</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt next_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> =
<span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt prev_st token_id addr <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr) <span class="nb">eqn</span>:Heq1;
    <span class="nb">destruct</span> (get_balance_opt prev_st token_id addr) <span class="nb">eqn</span>:Heq2;<span class="nb">auto</span>;
      <span class="nb">inversion</span> H;<span class="kp">try</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8b"><span class="kn">Lemma</span> <span class="nf">same_owners_remove_all</span>  `{ChainBase} token_id addrs next_st prev_st :
    (<span class="kr">forall</span> <span class="nv">addr1</span>, ~ In addr1 addrs -&gt;
    get_balance_opt next_st token_id addr1 = get_balance_opt prev_st token_id addr1) -&gt;
    (<span class="kr">forall</span> <span class="nv">addr1</span>, In addr1 (remove_all addr_eq_dec addrs (get_owners next_st token_id))
              &lt;-&gt; In addr1 (remove_all addr_eq_dec addrs (get_owners prev_st token_id))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr1</span> : Address,
 ~ In addr1 addrs -&gt;
 get_balance_opt next_st token_id addr1 =
 get_balance_opt prev_st token_id addr1) -&gt;
<span class="kr">forall</span> <span class="nv">addr1</span> : Address,
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) &lt;-&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">addr1</span> : Address,
 ~ In addr1 addrs -&gt;
 get_balance_opt next_st token_id addr1 =
 get_balance_opt prev_st token_id addr1) -&gt;
<span class="kr">forall</span> <span class="nv">addr1</span> : Address,
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) &lt;-&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8d"><span class="nb">intros</span> H0 addr1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) &lt;-&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk8e"><span class="nb">assert</span> (Hdec : <span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : Address), a1 = a2 \/ a1 &lt;&gt; a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk8f"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) &lt;-&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk90">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk91"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1, a1, a2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (addr_eq_dec a1 a2);<span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk92">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) &lt;-&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk93"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) -&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk94"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id)) -&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk95">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id)) -&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk96"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk97"><span class="nb">destruct</span> (ListDec.In_decidable Hdec addr1 addrs) <span class="kr">as</span> [Hin_addrs | Hnotin_addrs];<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk98" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk98"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk99">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9a"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9b"><span class="nb">assert</span> (Hall : Forall (<span class="kr">fun</span> <span class="nv">x</span> =&gt;~In x (remove_all addr_eq_dec addrs ((get_owners next_st token_id)))) addrs)
          <span class="bp">by</span> <span class="nb">apply</span> remove_all_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> <span class="nv">x</span> : Address =&gt;
   ~
   In x
     (remove_all addr_eq_dec addrs
        (get_owners next_st token_id))) addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Forall_forall <span class="kr">in</span> Hall;<span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9d"><span class="nb">specialize</span> (H0 _ Hnotin_addrs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk9e"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr1) <span class="nb">eqn</span>:Hnext;<span class="nb">inversion</span> Hnext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk9f"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka0">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka1"><span class="nb">apply</span> remove_all_not_in_to_remove;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_owners prev_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka2">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka3"><span class="nb">apply</span> In_remove_all <span class="kr">in</span> Hin;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1 (get_owners next_st token_id)</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances <span class="kr">in</span> Hin;<span class="nb">destruct</span> Hin;<span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id)) -&gt;
In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka5"><span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka6"><span class="nb">destruct</span> (ListDec.In_decidable Hdec addr1 addrs) <span class="kr">as</span> [Hin_addrs | Hnotin_addrs];<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chka7"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chka9"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkaa"><span class="nb">assert</span> (Hall : Forall (<span class="kr">fun</span> <span class="nv">x</span> =&gt;~In x (remove_all addr_eq_dec addrs ((get_owners prev_st token_id)))) addrs)
          <span class="bp">by</span> <span class="nb">apply</span> remove_all_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hin_addrs</var><span class="hyp-type"><b>: </b><span>In addr1 addrs</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> <span class="nv">x</span> : Address =&gt;
   ~
   In x
     (remove_all addr_eq_dec addrs
        (get_owners prev_st token_id))) addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Forall_forall <span class="kr">in</span> Hall;<span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkab">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
~ In addr0 addrs -&gt;
get_balance_opt next_st token_id addr0 =
get_balance_opt prev_st token_id addr0</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkac"><span class="nb">specialize</span> (H0 _ Hnotin_addrs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkad"><span class="nb">destruct</span> (get_balance_opt next_st token_id addr1) <span class="nb">eqn</span>:Hnext;<span class="nb">inversion</span> Hnext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkae"><hr></label><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkaf">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb0"><span class="nb">apply</span> remove_all_not_in_to_remove;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 =
Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Some t = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1 (get_owners next_st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb1">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1
  (remove_all addr_eq_dec addrs
     (get_owners prev_st token_id))</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb2"><span class="nb">apply</span> In_remove_all <span class="kr">in</span> Hin;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>addrs</var><span class="hyp-type"><b>: </b><span>list Address</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>addr1</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hnext</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>None = get_balance_opt prev_st token_id addr1</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>In addr1 (get_owners prev_st token_id)</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In addr1 addrs</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_opt next_st token_id addr1 = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr1
  (remove_all addr_eq_dec addrs
     (get_owners next_st token_id))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_owners_balances <span class="kr">in</span> Hin;<span class="nb">destruct</span> Hin;<span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb3"><span class="kn">Lemma</span> <span class="nf">in_owners_or_zero_balance_total</span>  `{ChainBase} st token_id owner p :
    In owner (get_owners st token_id) \/ get_balance_total st token_id p owner = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb5"><span class="nb">assert</span> (Hdec : <span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : Address), a1 = a2 \/ a1 &lt;&gt; a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkb6"><hr></label><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (addr_eq_dec a1 a2);<span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkb9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkba"><span class="nb">destruct</span> (ListDec.In_decidable Hdec owner (get_owners st token_id)) <span class="kr">as</span> [Hin_addrs | Hnotin_addrs];<span class="nb">subst</span>;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkbb"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total st token_id p owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkbc"><span class="nb">unfold</span> get_balance_total,get_balance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None) <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     (<span class="kr">if</span> token_id_exists st token_id
      <span class="kr">then</span>
       <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
       | Some bal =&gt; Some bal
       | None =&gt; Some <span class="mi">0</span>
       <span class="kr">end</span>
      <span class="kr">else</span> None) -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          (<span class="kr">if</span> token_id_exists st token_id
           <span class="kr">then</span>
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal0 =&gt; Some bal0
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span>
           <span class="kr">else</span> None) =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            (<span class="kr">if</span> token_id_exists st token_id
             <span class="kr">then</span>
              <span class="kr">match</span>
                get_balance_opt st token_id owner
              <span class="kr">with</span>
              | Some bal =&gt; Some bal
              | None =&gt; Some <span class="mi">0</span>
              <span class="kr">end</span>
             <span class="kr">else</span> None) =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind (token_id_exists st token_id)
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt st token_id owner
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true p))
<span class="kr">end</span> eq_refl = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkbd"><span class="nb">rewrite</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind true
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt st token_id owner
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true eq_refl))
<span class="kr">end</span> eq_refl = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkbe"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span> heq)
<span class="kr">end</span> eq_refl = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkbf"><span class="nb">destruct</span> (get_balance_opt st token_id owner) <span class="nb">eqn</span>:Heq;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>get_balance_opt st token_id owner = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc0"><span class="nb">assert</span> (In owner (get_owners st token_id)) <span class="bp">by</span> (<span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>get_balance_opt st token_id owner = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc1"><span class="kn">Lemma</span> <span class="nf">in_owners_or_zero_balance_default</span>  `{ChainBase} st token_id owner :
    In owner (get_owners st token_id) \/ get_balance_default st token_id owner = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc3"><span class="nb">assert</span> (Hdec : <span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : Address), a1 = a2 \/ a1 &lt;&gt; a2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkc4"><hr></label><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner, a1, a2</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2 \/ a1 &lt;&gt; a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (addr_eq_dec a1 a2);<span class="nb">auto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc8"><span class="nb">destruct</span> (ListDec.In_decidable Hdec owner (get_owners st token_id)) <span class="kr">as</span> [Hin_addrs | Hnotin_addrs];<span class="nb">subst</span>;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In owner (get_owners st token_id) \/
get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkc9"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default st token_id owner = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkca"><span class="nb">unfold</span> get_balance_default,get_balance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkcb"><span class="nb">destruct</span> (token_id_exists st token_id);<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkcc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkcd"><span class="nb">destruct</span> (get_balance_opt st token_id owner) <span class="nb">eqn</span>:Heq;<span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>get_balance_opt st token_id owner = Some t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkce"><span class="nb">assert</span> (In owner (get_owners st token_id)) <span class="bp">by</span> (<span class="nb">apply</span> get_owners_balances;<span class="nb">eauto</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : Address, a1 = a2 \/ a1 &lt;&gt; a2</span></span></span><br><span><var>Hnotin_addrs</var><span class="hyp-type"><b>: </b><span>~ In owner (get_owners st token_id)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>get_balance_opt st token_id owner = Some t</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In owner (get_owners st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> in_owners_or_zero_balance_total in_owners_or_zero_balance_default get_owners_no_dup : hints.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkcf"><span class="kn">Lemma</span> <span class="nf">get_balance_total_get_balance_default</span> `{ChainBase} st token_id p owner:
    get_balance_total st token_id p owner = get_balance_default st token_id owner.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total st token_id p owner =
get_balance_default st token_id owner</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total st token_id p owner =
get_balance_default st token_id owner</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd1"><span class="nb">unfold</span> get_balance_total, get_balance_default, get_balance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None) <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     (<span class="kr">if</span> token_id_exists st token_id
      <span class="kr">then</span>
       <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
       | Some bal =&gt; Some bal
       | None =&gt; Some <span class="mi">0</span>
       <span class="kr">end</span>
      <span class="kr">else</span> None) -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          (<span class="kr">if</span> token_id_exists st token_id
           <span class="kr">then</span>
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal0 =&gt; Some bal0
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span>
           <span class="kr">else</span> None) =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            (<span class="kr">if</span> token_id_exists st token_id
             <span class="kr">then</span>
              <span class="kr">match</span>
                get_balance_opt st token_id owner
              <span class="kr">with</span>
              | Some bal =&gt; Some bal
              | None =&gt; Some <span class="mi">0</span>
              <span class="kr">end</span>
             <span class="kr">else</span> None) =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind (token_id_exists st token_id)
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt st token_id owner
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true p))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  (<span class="kr">if</span> token_id_exists st token_id
   <span class="kr">then</span>
    <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
    | Some bal =&gt; Some bal
    | None =&gt; Some <span class="mi">0</span>
    <span class="kr">end</span>
   <span class="kr">else</span> None)
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd2"><span class="nb">rewrite</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span>
         (eq_ind true
            (<span class="kr">fun</span> <span class="nv">b</span> : bool =&gt;
             None =
             (<span class="kr">if</span> b
              <span class="kr">then</span>
               <span class="kr">match</span>
                 get_balance_opt st token_id owner
               <span class="kr">with</span>
               | Some bal =&gt; Some bal
               | None =&gt; Some <span class="mi">0</span>
               <span class="kr">end</span>
              <span class="kr">else</span> None)) heq true eq_refl))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists st token_id = true</span></span></span><br><span><var>owner</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span> <span class="kr">as</span> o&#39;
  <span class="kr">return</span>
    (o&#39; =
     <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
     | Some bal =&gt; Some bal
     | None =&gt; Some <span class="mi">0</span>
     <span class="kr">end</span> -&gt; TokenAmount)
<span class="kr">with</span>
| Some bal =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : Some bal =
          <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
          | Some bal0 =&gt; Some bal0
          | None =&gt; Some <span class="mi">0</span>
          <span class="kr">end</span> =&gt; bal
| None =&gt;
    <span class="kr">fun</span>
      <span class="nv">heq</span> : None =
            <span class="kr">match</span>
              get_balance_opt st token_id owner
            <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> =&gt;
    False_rect TokenAmount
      (<span class="kr">match</span>
         get_balance_opt st token_id owner <span class="kr">as</span> o
         <span class="kr">return</span>
           (None =
            <span class="kr">match</span> o <span class="kr">with</span>
            | Some bal =&gt; Some bal
            | None =&gt; Some <span class="mi">0</span>
            <span class="kr">end</span> -&gt; <span class="kt">False</span>)
       <span class="kr">with</span>
       | Some t =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some t =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some t) heq0)
       | None =&gt;
           <span class="kr">fun</span> <span class="nv">heq0</span> : None = Some <span class="mi">0</span> =&gt;
           False_ind <span class="kt">False</span>
             (eq_ind None
                (<span class="kr">fun</span> <span class="nv">e</span> : option TokenAmount =&gt;
                 <span class="kr">match</span> e <span class="kr">with</span>
                 | Some _ =&gt; <span class="kt">False</span>
                 | None =&gt; <span class="kt">True</span>
                 <span class="kr">end</span>) I (Some <span class="mi">0</span>) heq0)
       <span class="kr">end</span> heq)
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  <span class="kr">match</span> get_balance_opt st token_id owner <span class="kr">with</span>
  | Some bal =&gt; Some bal
  | None =&gt; Some <span class="mi">0</span>
  <span class="kr">end</span>
<span class="kr">with</span>
| Some amount =&gt; amount
| None =&gt; <span class="mi">0</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">destruct</span> (get_balance_opt st token_id _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
We can recover a statement for the whole "batch" of transfers from the transfers spec where
      the same property is assumed for each transfer in the batch 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd4"><span class="kn">Lemma</span> <span class="nf">transfer_token_ids_preserved</span> `{ChainBase} transfers prev_st next_st ops :
      <span class="kr">let</span> <span class="nv">params</span> := Build_CIS1_transfer_params _ transfers <span class="kr">in</span>
      transfer_spec params prev_st next_st ops -&gt;
      <span class="kr">forall</span> <span class="nv">token_id</span>,
        token_id_exists prev_st token_id =  token_id_exists next_st token_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd6"><span class="nb">revert dependent</span> prev_st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">prev_st</span> : Storage,
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd7"><span class="nb">revert dependent</span> ops.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
transfer_spec {| cis_tr_transfers := transfers |}
  prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkd9"><span class="nb">induction</span> transfers.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
transfer_spec {| cis_tr_transfers := [] |} prev_st
  next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkda"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
transfer_spec {| cis_tr_transfers := a :: transfers |}
  prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkdb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
transfer_spec {| cis_tr_transfers := [] |} prev_st
  next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkdc"><span class="nb">intros</span> ops prev_st spec token_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec {| cis_tr_transfers := [] |}
  prev_st next_st ops</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkdd"><span class="nb">destruct</span> spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>transfer_dec_inc0</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := [] |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) =
          true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) =
          true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x)
     (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>transfer_receive_hook_calls0</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span>
  <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span>
       <span class="nv">x</span> : CIS1_transfer_data
     =&gt;
     address_is_contract
       (cis1_td_to x))
    (cis_tr_transfers
       {|
       cis_tr_transfers := [] |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span>
     &#39;(op,
      (to_addr, params))
   =&gt;
   <span class="kr">exists</span>
     <span class="nv">val</span> : SerializedValue,
     op =
     act_call to_addr <span class="mi">0</span>
       val /\
     is_valid_receive_hook
       params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span>
     &#39;(to_addr, params)
   =&gt;
   act_call to_addr <span class="mi">0</span>
     (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span> <span class="kr">in</span> *;<span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkde">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody) (<span class="nv">prev_st</span> : Storage),
transfer_spec {| cis_tr_transfers := a :: transfers |}
  prev_st next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkdf"><span class="nb">intros</span> ops prev_st spec token_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec
  {| cis_tr_transfers := a :: transfers |}
  prev_st next_st ops</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke0"><span class="nb">destruct</span> spec <span class="kr">as</span> [Htrans Hcalls].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := a :: transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {|
       cis_tr_transfers := a :: transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke1"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span>
  (<span class="nv">st</span> : Storage) (<span class="nv">p</span> : 
                  token_id_exists prev_st
                    (cis1_td_token_id a) =
                  true) 
(<span class="nv">q</span> : token_id_exists st (cis1_td_token_id a) =
     true),
  transfer_single_spec prev_st st
    (cis1_td_token_id a) p q 
    (cis1_td_from a) (cis1_td_to a)
    (cis1_td_amount a) /\
  compose_transfers st next_st transfers
    (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
       (<span class="nv">x</span> : CIS1_transfer_data)
       (<span class="nv">p0</span> : token_id_exists st1
               (cis1_td_token_id x) = true)
       (<span class="nv">q0</span> : token_id_exists st2
               (cis1_td_token_id x) = true)
     =&gt;
     transfer_single_spec st1 st2
       (cis1_td_token_id x) p0 q0
       (cis1_td_from x) 
       (cis1_td_to x) 
       (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke2"><span class="nb">destruct</span> Htrans <span class="kr">as</span> [st [p [q [Hsingle Htrs]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke3"><span class="nb">transitivity</span> (token_id_exists st token_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists st token_id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chke4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chke4"><hr></label><div class="goal-conclusion">token_id_exists st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke5">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists prev_st token_id =
token_id_exists st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">destruct</span> Hsingle <span class="kr">as</span> [HH0 [HH1 [HH2 HH3]]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke6">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">token_id_exists st token_id =
token_id_exists next_st token_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke7"><span class="nb">eapply</span> IHtransfers;<span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transfer_spec {| cis_tr_transfers := transfers |} st
  next_st <span class="nl">?ops</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chke8"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">compose_transfers st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage) (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1 (cis1_td_token_id x) =
           true)
     (<span class="nv">q0</span> : token_id_exists st2 (cis1_td_token_id x) =
           true) =&gt;
   transfer_single_spec st1 st2 (cis1_td_token_id x)
     p0 q0 (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chke9"><hr></label><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := transfers |}) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>
     (get_receive_hook_params transfers_to_contracts)) /\
<span class="nl">?ops</span> =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params transfers_to_contracts)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkea"><span class="nb">apply</span> Htrs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := transfers |}) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>
     (get_receive_hook_params transfers_to_contracts)) /\
<span class="nl">?ops</span> =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params transfers_to_contracts)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkeb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span> =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkec"><span class="nb">destruct</span> Hcalls <span class="kr">as</span> [Hforall Hops].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
                =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract (cis1_td_to x))
            transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops}
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops} =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chked"><span class="nb">destruct</span> (address_is_contract (cis1_td_to a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops}
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops} =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkee"><hr></label><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops}
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, 
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops} =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkef">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine <span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops}
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span>@{Hcalls:=conj Hforall Hops} =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf0"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
         act_call to_addr <span class="mi">0</span>
           (serialize params))
        (map
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x,
            (cis1_td_token_id x,
            cis1_td_amount x,
            cis1_td_from x)))
           (a
            :: filter
                 (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
                  =&gt;
                  address_is_contract
                    (cis1_td_to x))
                 transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine
     <span class="nl">?ops</span>@{ops:=map
                  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
                   act_call to_addr <span class="mi">0</span>
                     (serialize params))
                  (map
                     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                      (cis1_td_to x,
                      (cis1_td_token_id x,
                      cis1_td_amount x,
                      cis1_td_from x)))
                     (a
                      :: filter
                           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
                            =&gt;
                            address_is_contract
                              (cis1_td_to x))
                           transfers))}
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
<span class="nl">?ops</span>@{ops:=map
             (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
              act_call to_addr <span class="mi">0</span> (serialize params))
             (map
                (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                 (cis1_td_to x,
                 (cis1_td_token_id x,
                 cis1_td_amount x, cis1_td_from x)))
                (a
                 :: filter
                      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                       address_is_contract
                         (cis1_td_to x)) transfers))} =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">inversion</span> Hforall;<span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf1">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st ops0 -&gt;
<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st0 token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
         act_call to_addr <span class="mi">0</span> (serialize params))
        (map
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x,
            (cis1_td_token_id x, cis1_td_amount x,
            cis1_td_from x)))
           (filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract (cis1_td_to x))
              transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x, cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))) /\
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers)) =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, cis1_td_amount x,
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x)) transfers))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
The balances of all token-address pairs NOT mentioned in the transfer batch remain unchanged
  
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf2"><span class="kn">Lemma</span> <span class="nf">transfer_other_balances_preserved</span> `{ChainBase} transfers prev_st next_st ops :
    <span class="kr">let</span> <span class="nv">params</span> := Build_CIS1_transfer_params _ transfers <span class="kr">in</span>
    transfer_spec params prev_st next_st ops -&gt;
    <span class="kr">forall</span> <span class="nv">addr</span> <span class="nv">token_id</span>,
      ~ In (token_id, addr) (transfer_from params) -&gt;
      ~ In (token_id, addr) (transfer_to params)   -&gt;
    get_balance_opt prev_st token_id addr = get_balance_opt next_st token_id addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf4"><span class="nb">revert dependent</span> next_st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">next_st</span> : Storage,
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf5"><span class="nb">revert dependent</span> prev_st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage,
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf6"><span class="nb">revert dependent</span> ops.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf7"><span class="nb">induction</span> transfers.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := [] |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chkf8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">token_id</span> : TokenID),
~
In (token_id, addr)
  (transfer_from params) -&gt;
~
In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chkf8"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := a :: transfers |}
  <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkf9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := [] |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkfa"><span class="nb">cbn</span>;<span class="nb">intros</span> ops prev_st next_st spec addr token_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec {| cis_tr_transfers := [] |}
  prev_st next_st ops</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ <span class="kt">False</span> -&gt;
~ <span class="kt">False</span> -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkfb"><span class="nb">destruct</span> spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>transfer_dec_inc0</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := [] |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) =
          true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) =
          true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x)
     (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>transfer_receive_hook_calls0</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span>
  <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span>
       <span class="nv">x</span> : CIS1_transfer_data
     =&gt;
     address_is_contract
       (cis1_td_to x))
    (cis_tr_transfers
       {|
       cis_tr_transfers := [] |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span>
     &#39;(op,
      (to_addr, params))
   =&gt;
   <span class="kr">exists</span>
     <span class="nv">val</span> : SerializedValue,
     op =
     act_call to_addr <span class="mi">0</span>
       val /\
     is_valid_receive_hook
       params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span>
     &#39;(to_addr, params)
   =&gt;
   act_call to_addr <span class="mi">0</span>
     (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ <span class="kt">False</span> -&gt;
~ <span class="kt">False</span> -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span> <span class="kr">in</span> *;<span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkfc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">token_id</span> : TokenID),
~
In (token_id, addr)
  (transfer_from params) -&gt;
~
In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st</span> <span class="nv">next_st</span> : Storage),
<span class="kr">let</span> <span class="nv">params</span> := {| cis_tr_transfers := a :: transfers |}
  <span class="kr">in</span>
transfer_spec params prev_st next_st ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id</span> : TokenID),
~ In (token_id, addr) (transfer_from params) -&gt;
~ In (token_id, addr) (transfer_to params) -&gt;
get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkfd"><span class="nb">intros</span> ops prev_st next_st ? spec addr token_id Hfrom Hto.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec params prev_st next_st ops</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkfe"><span class="nb">destruct</span> spec <span class="kr">as</span> [Htr Hcalls].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers params)
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chkff"><span class="nb">destruct</span> Htr <span class="kr">as</span> [st [p [q [Hsingle Htrs]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk100"><span class="nb">assert</span> ((token_id, addr) &lt;&gt; (a.(cis1_td_token_id), a.(cis1_td_from)) /\ ~ (In (token_id,addr) (transfer_from params))) <span class="bp">by</span> <span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_to params)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk101"><span class="nb">assert</span> ((token_id, addr) &lt;&gt; (a.(cis1_td_token_id), a.(cis1_td_to)) /\ ~ (In (token_id,addr) (transfer_to params))) <span class="bp">by</span> <span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>Hto</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_to params)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk102"><span class="nb">clear</span> Hto.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hfrom</var><span class="hyp-type"><b>: </b><span>~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk103"><span class="nb">clear</span> Hfrom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk104"><span class="nb">transitivity</span> (get_balance_opt st token_id addr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk105"><hr></label><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk106">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk107"><span class="nb">destruct</span> Hsingle <span class="kr">as</span> [Hbal_not_addr [Hbal_other_tokens [? ?]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk108"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk109"><span class="nb">destruct</span> (Nat.eq_dec token_id a.(cis1_td_token_id)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk10a"><hr></label><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10c"><span class="nb">assert</span> (addr &lt;&gt; a.(cis1_td_to)) <span class="bp">by</span> <span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_to a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10d"><span class="nb">assert</span> (addr &lt;&gt; a.(cis1_td_from)) <span class="bp">by</span> <span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_to a</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_from a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10e"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id</span> : TokenID),
~
In (token_id, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id addr0 =
get_balance_opt next_st0 token_id addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists st token_id</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(cis1_td_token_id a, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (cis1_td_token_id a, addr) \/
 In (cis1_td_token_id a, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(cis1_td_token_id a, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (cis1_td_token_id a, addr) \/
 In (cis1_td_token_id a, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_to a</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_from a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st (cis1_td_token_id a) addr =
get_balance_opt st (cis1_td_token_id a) addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk10f"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id</span> : TokenID),
~
In (token_id, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id addr0 =
get_balance_opt next_st0 token_id addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id</span> : TokenID,
token_id_exists prev_st token_id =
token_id_exists st token_id</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(cis1_td_token_id a, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (cis1_td_token_id a, addr) \/
 In (cis1_td_token_id a, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(cis1_td_token_id a, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (cis1_td_token_id a, addr) \/
 In (cis1_td_token_id a, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_to a</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; cis1_td_from a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> Hbal_not_addr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk110">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hbal_not_addr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st
  (cis1_td_token_id a) addr0 =
get_balance_opt prev_st
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>Hbal_other_tokens</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt;
cis1_td_token_id a -&gt;
get_balance_opt st other_token_id
  addr0 =
get_balance_opt prev_st
  other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt prev_st token_id addr =
get_balance_opt st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">symmetry</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk111">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
<span class="kr">let</span> <span class="nv">params0</span> :=
  {| cis_tr_transfers := transfers |} <span class="kr">in</span>
transfer_spec params0 prev_st0 next_st0
  ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (transfer_from params0) -&gt;
~
In (token_id0, addr0)
  (transfer_to params0) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers params) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~ In (token_id, addr) (transfer_from params)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~ In (token_id, addr) (transfer_to params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk112"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk113"><span class="nb">destruct</span> Hcalls <span class="kr">as</span> [Hforall Hops].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
                =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract (cis1_td_to x))
            transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk114"><span class="nb">destruct</span> (address_is_contract (cis1_td_to a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk115"><hr></label><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk116">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk117"><span class="nb">subst</span>;<span class="nb">inversion</span> Hforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x0,
      cis1_td_from x0)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x0,
      cis1_td_to x0)) transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x0</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x0) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x0) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x0) p0 q0
     (cis1_td_from x0) 
     (cis1_td_to x0) (cis1_td_amount x0))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
         act_call to_addr <span class="mi">0</span>
           (serialize params0))
        (map
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x0,
            (cis1_td_token_id x0,
            cis1_td_amount x0,
            cis1_td_from x0)))
           (a
            :: filter
                 (<span class="kr">fun</span>
                    <span class="nv">x0</span> : CIS1_transfer_data
                  =&gt;
                  address_is_contract
                    (cis1_td_to x0))
                 transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0,
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data
               =&gt;
               address_is_contract
                 (cis1_td_to x0)) transfers)))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x0, cis1_td_from x0))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x0, cis1_td_to x0))
      transfers))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(ActionBody * (Address * receive_hook_params))%type</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list
  (ActionBody * (Address * receive_hook_params))</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
  act_call (cis1_td_to a) <span class="mi">0</span>
    (serialize
       (cis1_td_token_id a, 
       cis1_td_amount a, 
       cis1_td_from a)) =
  act_call (cis1_td_to a) <span class="mi">0</span> val /\
  is_valid_receive_hook
    (cis1_td_token_id a, 
    cis1_td_amount a, 
    cis1_td_from a) val</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
         act_call to_addr <span class="mi">0</span> (serialize params0))
        (map
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x0,
            (cis1_td_token_id x0,
            cis1_td_amount x0, 
            cis1_td_from x0)))
           (filter
              (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x0)) transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0, 
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x0))
           transfers)))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x =
(act_call (cis1_td_to a) <span class="mi">0</span>
   (serialize
      (cis1_td_token_id a, 
      cis1_td_amount a, 
      cis1_td_from a)),
(cis1_td_to a,
(cis1_td_token_id a, cis1_td_amount a,
cis1_td_from a)))</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>l =
combine
  (map
     (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
      act_call to_addr <span class="mi">0</span> (serialize params0))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0, 
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x0))
           transfers)))
  (map
     (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x0,
      (cis1_td_token_id x0, 
      cis1_td_amount x0, 
      cis1_td_from x0)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x0))
        transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> IHtransfers;<span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk118">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ops0</span> : list ActionBody)
  (<span class="nv">prev_st0</span> <span class="nv">next_st0</span> : Storage),
transfer_spec
  {| cis_tr_transfers := transfers |}
  prev_st0 next_st0 ops0 -&gt;
<span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">token_id0</span> : TokenID),
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x,
      cis1_td_from x)) transfers) -&gt;
~
In (token_id0, addr0)
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_token_id x, cis1_td_to x))
     transfers) -&gt;
get_balance_opt prev_st0 token_id0 addr0 =
get_balance_opt next_st0 token_id0 addr0</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>params</var><span><span class="hyp-body"><b>:= </b><span>{| cis_tr_transfers := a :: transfers |}</span></span><span class="hyp-type"><b>: </b><span>CIS1_transfer_params</span></span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params0)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params0 val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params0) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params0))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_from a) /\
~
((cis1_td_token_id a, cis1_td_from a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_from x))
      transfers))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>(token_id, addr) &lt;&gt;
(cis1_td_token_id a, cis1_td_to a) /\
~
((cis1_td_token_id a, cis1_td_to a) =
 (token_id, addr) \/
 In (token_id, addr)
   (map
      (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
       (cis1_td_token_id x, cis1_td_to x))
      transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt st token_id addr =
get_balance_opt next_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> IHtransfers;<span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
If the properties of the single transfer holds (the transfer succeeds), then
      we can conclude that if has been enough tokens for the transfer. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk119"><span class="kn">Lemma</span> <span class="nf">transfer_single_spec_sufficient_funds</span> `{ChainBase}
        prev_st next_st token_id <span class="kn">from</span> to amount
        (p : token_id_exists prev_st token_id)
        (q : token_id_exists next_st token_id)
        (spec : transfer_single_spec prev_st next_st token_id p q <span class="kn">from</span> to amount) :
    get_balance_total prev_st token_id p <span class="kn">from</span> &gt;= amount.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st next_st token_id p
  q <span class="kn">from</span> to amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total prev_st token_id p <span class="kn">from</span> &gt;= amount</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st next_st token_id p
  q <span class="kn">from</span> to amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total prev_st token_id p <span class="kn">from</span> &gt;= amount</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11b"><span class="nb">destruct</span> spec <span class="kr">as</span> [H1 [H2 H3]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
 token_id_exists prev_st token_id0 =
 token_id_exists next_st token_id0) /\
get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount /\
get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_total prev_st token_id p <span class="kn">from</span> &gt;= amount</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
An important lemma for the main result. The spec for a single transfer ensures that for a
      particular <span class="inlinecode"><span class="id" title="var">token_id</span></span> the sum of balances is preserved for all owners for one transfer
      of an <span class="inlinecode"><span class="id" title="var">amount</span></span> between <span class="inlinecode"><span class="id" title="var">from</span></span> and <span class="inlinecode"><span class="id" title="var">to</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11c"><span class="kn">Lemma</span> <span class="nf">transfer_single_spec_preserves_balances</span> `{ChainBase}
        prev_st next_st token_id <span class="kn">from</span> to amount
        (p : token_id_exists prev_st token_id)
        (q : token_id_exists next_st token_id)
        (spec : transfer_single_spec prev_st next_st token_id p q <span class="kn">from</span> to amount) :
    <span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
    sum_balances next_st token_id owners2 =
    sum_balances prev_st token_id owners1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st next_st token_id p
  q <span class="kn">from</span> to amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st next_st token_id p
  q <span class="kn">from</span> to amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11e"><span class="nb">intros</span> ??.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st next_st token_id p
  q <span class="kn">from</span> to amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk11f"><span class="nb">destruct</span> spec <span class="kr">as</span> [Hother_balances [H1 [H2 [H3 H4]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk120"><span class="nb">unfold</span> transfer_single_spec <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk121"><span class="nb">destruct</span> (address_eqb_spec <span class="kn">from</span> to) <span class="kr">as</span> [Haddr | Haddr].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> = to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk122" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk122"><hr></label><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk123">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> = to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk124"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk125"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := prev_st) (owner := to)
         <span class="bp">by</span> (<span class="nb">subst</span> owners1;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
get_balance_default prev_st token_id to +
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk126"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := next_st) (owner := to)
        <span class="bp">by</span> (<span class="nb">subst</span> owners2;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id to +
sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
get_balance_default prev_st token_id to +
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk127"><span class="nb">assert</span> (HH :
                sum_balances next_st token_id (remove addr_eq_dec to owners2) =
                sum_balances prev_st token_id (remove addr_eq_dec to owners1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk128" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk128"><hr></label><div class="goal-conclusion">get_balance_default next_st token_id to +
sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
get_balance_default prev_st token_id to +
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk129">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk12a"><span class="nb">apply</span> sum_of_balances_eq_extensional;<span class="nb">subst</span> owners2;<span class="nb">subst</span> owners1;<span class="nb">eauto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to (get_owners next_st token_id)) &lt;-&gt;
In addr
  (remove addr_eq_dec to (get_owners prev_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk12b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk12b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to (get_owners next_st token_id)) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk12c"><span class="nb">intros</span> addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr
  (remove addr_eq_dec to (get_owners next_st token_id)) &lt;-&gt;
In addr
  (remove addr_eq_dec to (get_owners prev_st token_id))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk12d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk12d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to (get_owners next_st token_id)) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk12e"><span class="nb">apply</span> same_owners_remove_all <span class="kr">with</span> (addrs:=[to]);<span class="nb">intros</span>;<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="nb">intuition</span>;<span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to (get_owners next_st token_id)) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk12f"><span class="nb">intros</span> addr H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk130"><span class="nb">unfold</span> is_true <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk131"><span class="nb">apply</span> get_balance_opt_default;<span class="kp">try</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk132"><span class="nb">destruct</span> (address_eqb_spec addr to);<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In to
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id to =
get_balance_opt prev_st token_id to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk133" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk133"><hr></label><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk134"><span class="nb">exfalso</span>;<span class="nb">apply</span> (remove_In _ _ _ H0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; to -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (get_owners next_st token_id))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk135">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p to =
get_balance_total next_st token_id q to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id to +
sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
get_balance_default prev_st token_id to +
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk136"><span class="kp">repeat</span> <span class="nb">rewrite</span> get_balance_total_get_balance_default <span class="kr">in</span> H3, H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; to -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id to =
get_balance_default next_st token_id to + amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id to +
sum_balances next_st token_id
  (remove addr_eq_dec to owners2) =
get_balance_default prev_st token_id to +
sum_balances prev_st token_id
  (remove addr_eq_dec to owners1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk137">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk138"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := prev_st) (owner := <span class="kn">from</span>)
        <span class="bp">by</span> (<span class="nb">subst</span> owners1;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
get_balance_default prev_st token_id <span class="kn">from</span> +
sum_balances prev_st token_id
  (remove addr_eq_dec <span class="kn">from</span> owners1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk139"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := prev_st) (owner := to)
        <span class="bp">by</span> (<span class="nb">assert</span> (In to owners1 \/ get_balance_default prev_st token_id to = <span class="mi">0</span>); <span class="nb">subst</span> owners1;<span class="nb">auto with</span> hints;<span class="nb">intuition</span>;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
get_balance_default prev_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13a"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := next_st) (owner := <span class="kn">from</span>)
        <span class="bp">by</span> (<span class="nb">subst</span> owners2;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
sum_balances next_st token_id
  (remove addr_eq_dec <span class="kn">from</span> owners2) =
get_balance_default prev_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13b"><span class="nb">rewrite</span> remove_owner <span class="kr">with</span> (st := next_st) (owner := to)
        <span class="bp">by</span> (<span class="nb">assert</span> (In to owners2 \/ get_balance_default next_st token_id to = <span class="mi">0</span>);
            <span class="nb">subst</span> owners2;<span class="nb">auto with</span> hints;<span class="nb">intuition</span>;<span class="nb">auto with</span> hints).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st token_id p <span class="kn">from</span> =
get_balance_total next_st token_id q <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_total next_st token_id q to =
get_balance_total prev_st token_id p to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default next_st token_id to +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default prev_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13c"><span class="kp">repeat</span> <span class="nb">rewrite</span> get_balance_total_get_balance_default <span class="kr">in</span> H3, H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default next_st token_id to +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default prev_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13d"><span class="nb">rewrite</span> H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default next_st token_id to +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default next_st token_id <span class="kn">from</span> + amount +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13e"><span class="nb">rewrite</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to + amount +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default next_st token_id <span class="kn">from</span> + amount +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk13f"><span class="nb">assert</span> (HH :
                sum_balances next_st token_id (remove addr_eq_dec to (remove addr_eq_dec <span class="kn">from</span> owners2)) =
              sum_balances prev_st token_id (remove addr_eq_dec to (remove addr_eq_dec <span class="kn">from</span> owners1))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners2)) =
sum_balances prev_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners1))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk140" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>sum_balances next_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners2)) =
sum_balances prev_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners1))</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk140"><hr></label><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to + amount +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default next_st token_id <span class="kn">from</span> + amount +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk141">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners2)) =
sum_balances prev_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk142"><span class="nb">apply</span> sum_of_balances_eq_extensional;<span class="nb">subst</span> owners2;<span class="nb">subst</span> owners1;<span class="nb">eauto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id))) &lt;-&gt;
In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners prev_st token_id)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk143"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id))) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk144"><span class="nb">apply</span> same_owners_remove_all <span class="kr">with</span> (addrs:=[to;<span class="kn">from</span>]);<span class="nb">intros</span>;<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="nb">intuition</span>;<span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id))) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk145"><span class="nb">intros</span> addr H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk146"><span class="nb">unfold</span> is_true <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk147"><span class="nb">apply</span> get_balance_opt_default;<span class="kp">try</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk148"><span class="nb">destruct</span> (address_eqb_spec addr to);<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In to
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id to =
get_balance_opt prev_st token_id to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk149" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk149"><hr></label><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk14a"><span class="nb">exfalso</span>;<span class="nb">apply</span> (remove_In _ _ _ H0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk14b"><span class="nb">destruct</span> (address_eqb_spec addr <span class="kn">from</span>);<span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr, n</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In <span class="kn">from</span>
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id <span class="kn">from</span> =
get_balance_opt prev_st token_id <span class="kn">from</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; <span class="kn">from</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk14c"><hr></label><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk14d"><span class="nb">apply</span> In_remove <span class="kr">in</span> H0; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr, n</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In <span class="kn">from</span>
  (remove addr_eq_dec <span class="kn">from</span>
     (get_owners next_st token_id))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id <span class="kn">from</span> =
get_balance_opt prev_st token_id <span class="kn">from</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; <span class="kn">from</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk14e"><hr></label><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk14f"><span class="nb">exfalso</span>;<span class="nb">apply</span> (remove_In _ _ _ H0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st token_id = true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists next_st token_id = true</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; <span class="kn">from</span> -&gt;
addr0 &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr0 =
get_balance_opt prev_st token_id
  addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span>
        (get_owners next_st token_id)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; to</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>addr &lt;&gt; <span class="kn">from</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_opt next_st token_id addr =
get_balance_opt prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk150">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>from, to</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>amount</var><span class="hyp-type"><b>: </b><span>TokenAmount</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists prev_st token_id)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>is_true (token_id_exists next_st token_id)</span></span></span><br><span><var>Hother_balances</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; <span class="kn">from</span> -&gt;
addr &lt;&gt; to -&gt;
get_balance_opt next_st token_id
  addr =
get_balance_opt prev_st token_id
  addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; token_id -&gt;
get_balance_opt next_st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>get_balance_default prev_st token_id <span class="kn">from</span> =
get_balance_default next_st token_id <span class="kn">from</span> +
amount</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>get_balance_default next_st token_id to =
get_balance_default prev_st token_id to + amount</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>Haddr</var><span class="hyp-type"><b>: </b><span><span class="kn">from</span> &lt;&gt; to</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span>sum_balances next_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners2)) =
sum_balances prev_st token_id
  (remove addr_eq_dec to
     (remove addr_eq_dec <span class="kn">from</span> owners1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id <span class="kn">from</span> +
(get_balance_default prev_st token_id to + amount +
 sum_balances next_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners2))) =
get_balance_default next_st token_id <span class="kn">from</span> + amount +
(get_balance_default prev_st token_id to +
 sum_balances prev_st token_id
   (remove addr_eq_dec to
      (remove addr_eq_dec <span class="kn">from</span> owners1)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<a name="lab17"></a><h4 class="section">Main result</h4>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span></pre><div class="doc">
The prove our main result about the CIS1 standard with relation to the token balances.
      Namely, we prove that all the supported entry points preserve the sum of balances for all
      token types. The results hold for any contrac that complies with the abstract interface
      of the CIS1 standard. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk151"><span class="kn">Lemma</span> <span class="nf">transfer_preserves_sum_of_balances</span> `{ChainBase} prev_st next_st ops transfers token_id
        (spec : transfer_spec (Build_CIS1_transfer_params _ transfers) prev_st next_st ops) :
    <span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
    sum_balances prev_st token_id owners1 = sum_balances next_st token_id owners2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec
  {| cis_tr_transfers := transfers |} prev_st
  next_st ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk152"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>transfer_spec
  {| cis_tr_transfers := transfers |} prev_st
  next_st ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk153"><span class="nb">destruct</span> spec <span class="kr">as</span> [Htr Hcalls].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk154"><span class="nb">revert dependent</span> prev_st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">prev_st</span> : Storage,
compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage) (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1 (cis1_td_token_id x) =
          true)
     (<span class="nv">q</span> : token_id_exists st2 (cis1_td_token_id x) =
          true) =&gt;
   transfer_single_spec st1 st2 (cis1_td_token_id x) p
     q (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x)) -&gt;
<span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk155"><span class="nb">revert dependent</span> next_st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">next_st</span> <span class="nv">prev_st</span> : Storage,
compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage) (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1 (cis1_td_token_id x) =
          true)
     (<span class="nv">q</span> : token_id_exists st2 (cis1_td_token_id x) =
          true) =&gt;
   transfer_single_spec st1 st2 (cis1_td_token_id x) p
     q (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x)) -&gt;
<span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk156"><span class="nb">revert dependent</span> ops.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ops</span> : list ActionBody,
(<span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
   filter
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      address_is_contract (cis1_td_to x))
     (cis_tr_transfers
        {| cis_tr_transfers := transfers |}) <span class="kr">in</span>
 Forall
   (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
    <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
      op = act_call to_addr <span class="mi">0</span> val /\
      is_valid_receive_hook params val)
   (combine ops
      (get_receive_hook_params transfers_to_contracts)) /\
 ops =
 map
   (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
    act_call to_addr <span class="mi">0</span> (serialize params))
   (get_receive_hook_params transfers_to_contracts)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st</span> <span class="nv">prev_st</span> : Storage,
compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage) (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1 (cis1_td_token_id x) =
          true)
     (<span class="nv">q</span> : token_id_exists st2 (cis1_td_token_id x) =
          true) =&gt;
   transfer_single_spec st1 st2 (cis1_td_token_id x) p
     q (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x)) -&gt;
<span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk157"><span class="nb">induction</span> transfers;<span class="nb">intros</span> ops ? next_st prev_st Htr ? ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := [] |}) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers {| cis_tr_transfers := [] |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk158" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
(<span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
   filter
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      address_is_contract (cis1_td_to x))
     (cis_tr_transfers
        {|
        cis_tr_transfers := transfers |})
   <span class="kr">in</span>
 Forall
   (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
    <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
      op = act_call to_addr <span class="mi">0</span> val /\
      is_valid_receive_hook params val)
   (combine ops0
      (get_receive_hook_params
         transfers_to_contracts)) /\
 ops0 =
 map
   (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
    act_call to_addr <span class="mi">0</span>
      (serialize params))
   (get_receive_hook_params
      transfers_to_contracts)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x)) -&gt;
<span class="kr">let</span> <span class="nv">owners0</span> :=
  get_owners prev_st0 token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners3</span> :=
  get_owners next_st0 token_id <span class="kr">in</span>
sum_balances prev_st0 token_id owners0 =
sum_balances next_st0 token_id owners3</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {|
       cis_tr_transfers := a :: transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := a :: transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk158"><hr></label><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk159">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {| cis_tr_transfers := [] |}) <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers {| cis_tr_transfers := [] |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) (cis1_td_to x)
     (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15a"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops []) /\ ops = []</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>prev_st = next_st</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
(<span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
   filter
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      address_is_contract (cis1_td_to x))
     (cis_tr_transfers
        {|
        cis_tr_transfers := transfers |})
   <span class="kr">in</span>
 Forall
   (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
    <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
      op = act_call to_addr <span class="mi">0</span> val /\
      is_valid_receive_hook params val)
   (combine ops0
      (get_receive_hook_params
         transfers_to_contracts)) /\
 ops0 =
 map
   (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
    act_call to_addr <span class="mi">0</span>
      (serialize params))
   (get_receive_hook_params
      transfers_to_contracts)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  (cis_tr_transfers
     {| cis_tr_transfers := transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
<span class="kr">let</span> <span class="nv">owners0</span> :=
  get_owners prev_st0 token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners3</span> :=
  get_owners next_st0 token_id <span class="kr">in</span>
sum_balances prev_st0 token_id owners0 =
sum_balances next_st0 token_id owners3</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">transfers_to_contracts</span> :=
  filter
    (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
     address_is_contract (cis1_td_to x))
    (cis_tr_transfers
       {|
       cis_tr_transfers := a :: transfers |})
  <span class="kr">in</span>
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (get_receive_hook_params
        transfers_to_contracts)) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (get_receive_hook_params
     transfers_to_contracts)</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>compose_transfers prev_st next_st
  (cis_tr_transfers
     {| cis_tr_transfers := a :: transfers |})
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q 
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15c"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p</span> : token_id_exists st1
            (cis1_td_token_id x) = true)
     (<span class="nv">q</span> : token_id_exists st2
            (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p q
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span>
  (<span class="nv">st</span> : Storage) (<span class="nv">p</span> : 
                  token_id_exists prev_st
                    (cis1_td_token_id a) = true) 
(<span class="nv">q</span> : token_id_exists st (cis1_td_token_id a) =
     true),
  transfer_single_spec prev_st st
    (cis1_td_token_id a) p q 
    (cis1_td_from a) (cis1_td_to a)
    (cis1_td_amount a) /\
  compose_transfers st next_st transfers
    (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
       (<span class="nv">x</span> : CIS1_transfer_data)
       (<span class="nv">p0</span> : token_id_exists st1
               (cis1_td_token_id x) = true)
       (<span class="nv">q0</span> : token_id_exists st2
               (cis1_td_token_id x) = true) =&gt;
     transfer_single_spec st1 st2
       (cis1_td_token_id x) p0 q0
       (cis1_td_from x) 
       (cis1_td_to x) 
       (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15d"><span class="nb">destruct</span> Htr <span class="kr">as</span> [st [p [q [Hsingle Htrs]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk15e"><span class="nb">transitivity</span> (sum_balances st token_id (get_owners st token_id)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk15f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk15f"><hr></label><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk160">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk161"><span class="nb">destruct</span> (Nat.eq_dec token_id a.(cis1_td_token_id)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk162" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk162"><hr></label><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk163">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>token_id = cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk164"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0
  (cis1_td_token_id a)
  (get_owners prev_st0
     (cis1_td_token_id a)) =
sum_balances next_st0
  (cis1_td_token_id a)
  (get_owners next_st0
     (cis1_td_token_id a))</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st (cis1_td_token_id a)</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st (cis1_td_token_id a)</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st (cis1_td_token_id a) owners1 =
sum_balances st (cis1_td_token_id a)
  (get_owners st (cis1_td_token_id a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk165"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0
  (cis1_td_token_id a)
  (get_owners prev_st0
     (cis1_td_token_id a)) =
sum_balances next_st0
  (cis1_td_token_id a)
  (get_owners next_st0
     (cis1_td_token_id a))</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st (cis1_td_token_id a)</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st (cis1_td_token_id a)</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st (cis1_td_token_id a)
  (get_owners st (cis1_td_token_id a)) =
sum_balances prev_st (cis1_td_token_id a) owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">eapply</span> transfer_single_spec_preserves_balances <span class="kr">with</span> (next_st0 := st).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk166">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk167"><span class="nb">destruct</span> Hsingle <span class="kr">as</span> [? [HH [? ?]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; cis1_td_from a -&gt;
addr &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances prev_st token_id owners1 =
sum_balances st token_id (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk168"><span class="nb">apply</span> sum_of_balances_eq_extensional;<span class="nb">subst</span> owners2;<span class="nb">subst</span> owners1;<span class="nb">eauto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; cis1_td_from a -&gt;
addr &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners prev_st token_id) &lt;-&gt;
In addr (get_owners st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk169" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; cis1_td_from a -&gt;
addr &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk169"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners prev_st token_id) -&gt;
get_balance_default prev_st token_id addr =
get_balance_default st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16a">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; cis1_td_from a -&gt;
addr &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners prev_st token_id) &lt;-&gt;
In addr (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr0 =
get_balance_opt prev_st 
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners prev_st token_id) &lt;-&gt;
In addr (get_owners st token_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16c"><span class="kp">repeat</span> <span class="nb">rewrite</span> get_owners_balances.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr0 =
get_balance_opt prev_st 
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">balance</span> : TokenAmount,
   get_balance_opt prev_st token_id addr =
   Some balance) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">balance</span> : TokenAmount,
   get_balance_opt st token_id addr = Some balance)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">             </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> HH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16d">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
addr &lt;&gt; cis1_td_from a -&gt;
addr &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr =
get_balance_opt prev_st (cis1_td_token_id a) addr</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr =
get_balance_opt prev_st other_token_id addr</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners prev_st token_id) -&gt;
get_balance_default prev_st token_id addr =
get_balance_default st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
addr0 &lt;&gt; cis1_td_from a -&gt;
addr0 &lt;&gt; cis1_td_to a -&gt;
get_balance_opt st (cis1_td_token_id a) addr0 =
get_balance_opt prev_st 
  (cis1_td_token_id a) addr0</span></span></span><br><span><var>HH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address)
  (<span class="nv">other_token_id</span> : TokenID),
other_token_id &lt;&gt; cis1_td_token_id a -&gt;
get_balance_opt st other_token_id addr0 =
get_balance_opt prev_st other_token_id addr0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_from a) =
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_from a) + cis1_td_amount a /\
get_balance_total st (cis1_td_token_id a) q
  (cis1_td_to a) =
get_balance_total prev_st 
  (cis1_td_token_id a) p 
  (cis1_td_to a) + cis1_td_amount a</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>token_id &lt;&gt; cis1_td_token_id a</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>In addr (get_owners prev_st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default prev_st token_id addr =
get_balance_default st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> get_balance_opt_default;<span class="nb">symmetry</span>;<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk16f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk170"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hcalls</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk171"><span class="nb">destruct</span> Hcalls <span class="kr">as</span> [Hforall Hops].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (<span class="kr">if</span>
          address_is_contract (cis1_td_to a)
         <span class="kr">then</span>
          a
          :: filter
               (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
                =&gt;
                address_is_contract
                  (cis1_td_to x)) transfers
         <span class="kr">else</span>
          filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract
               (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (<span class="kr">if</span> address_is_contract (cis1_td_to a)
      <span class="kr">then</span>
       a
       :: filter
            (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
             address_is_contract (cis1_td_to x))
            transfers
      <span class="kr">else</span>
       filter
         (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
          address_is_contract (cis1_td_to x))
         transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk172"><span class="nb">destruct</span> (address_is_contract (cis1_td_to a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk173" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk173"><hr></label><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk174">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (a
      :: filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x))
           transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk175"><span class="nb">subst</span>;<span class="nb">inversion</span> Hforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0,
         cis1_td_amount x0,
         cis1_td_from x0)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x0)) transfers))) /\
ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x0,
      (cis1_td_token_id x0,
      cis1_td_amount x0,
      cis1_td_from x0)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x0)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x0</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x0) =
           true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x0) =
           true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x0) p0 q0
     (cis1_td_from x0) 
     (cis1_td_to x0) (cis1_td_amount x0)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
         act_call to_addr <span class="mi">0</span>
           (serialize params))
        (map
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x0,
            (cis1_td_token_id x0,
            cis1_td_amount x0,
            cis1_td_from x0)))
           (a
            :: filter
                 (<span class="kr">fun</span>
                    <span class="nv">x0</span> : CIS1_transfer_data
                  =&gt;
                  address_is_contract
                    (cis1_td_to x0))
                 transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0,
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (a
         :: filter
              (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data
               =&gt;
               address_is_contract
                 (cis1_td_to x0)) transfers)))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x0</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x0) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x0) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x0) p0 q0
     (cis1_td_from x0) 
     (cis1_td_to x0) (cis1_td_amount x0))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>(ActionBody * (Address * receive_hook_params))%type</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list
  (ActionBody * (Address * receive_hook_params))</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
  act_call (cis1_td_to a) <span class="mi">0</span>
    (serialize
       (cis1_td_token_id a, 
       cis1_td_amount a, 
       cis1_td_from a)) =
  act_call (cis1_td_to a) <span class="mi">0</span> val /\
  is_valid_receive_hook
    (cis1_td_token_id a, 
    cis1_td_amount a, 
    cis1_td_from a) val</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine
     (map
        (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
         act_call to_addr <span class="mi">0</span> (serialize params))
        (map
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            (cis1_td_to x0,
            (cis1_td_token_id x0,
            cis1_td_amount x0, 
            cis1_td_from x0)))
           (filter
              (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
               address_is_contract
                 (cis1_td_to x0)) transfers)))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0, 
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x0))
           transfers)))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x =
(act_call (cis1_td_to a) <span class="mi">0</span>
   (serialize
      (cis1_td_token_id a, 
      cis1_td_amount a, 
      cis1_td_from a)),
(cis1_td_to a,
(cis1_td_token_id a, cis1_td_amount a,
cis1_td_from a)))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>l =
combine
  (map
     (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
      act_call to_addr <span class="mi">0</span> (serialize params))
     (map
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x0,
         (cis1_td_token_id x0, 
         cis1_td_amount x0, 
         cis1_td_from x0)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
            address_is_contract (cis1_td_to x0))
           transfers)))
  (map
     (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x0,
      (cis1_td_token_id x0, 
      cis1_td_amount x0, 
      cis1_td_from x0)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x0</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x0))
        transfers))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> IHtransfers;<span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk176">**</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>CIS1_transfer_data</span></span></span><br><span><var>transfers</var><span class="hyp-type"><b>: </b><span>list CIS1_transfer_data</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>IHtransfers</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ops0</span> : list ActionBody,
Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops0
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x,
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data
            =&gt;
            address_is_contract
              (cis1_td_to x)) transfers))) /\
ops0 =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x,
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract
           (cis1_td_to x)) transfers)) -&gt;
<span class="kr">forall</span> <span class="nv">next_st0</span> <span class="nv">prev_st0</span> : Storage,
compose_transfers prev_st0 next_st0
  transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true)
   =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x)) -&gt;
sum_balances prev_st0 token_id
  (get_owners prev_st0 token_id) =
sum_balances next_st0 token_id
  (get_owners next_st0 token_id)</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>Hforall</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">fun</span> &#39;(op, (to_addr, params)) =&gt;
   <span class="kr">exists</span> <span class="nv">val</span> : SerializedValue,
     op = act_call to_addr <span class="mi">0</span> val /\
     is_valid_receive_hook params val)
  (combine ops
     (map
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         (cis1_td_to x,
         (cis1_td_token_id x,
         cis1_td_amount x, 
         cis1_td_from x)))
        (filter
           (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
            address_is_contract
              (cis1_td_to x)) transfers)))</span></span></span><br><span><var>Hops</var><span class="hyp-type"><b>: </b><span>ops =
map
  (<span class="kr">fun</span> &#39;(to_addr, params) =&gt;
   act_call to_addr <span class="mi">0</span> (serialize params))
  (map
     (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
      (cis1_td_to x,
      (cis1_td_token_id x, 
      cis1_td_amount x, 
      cis1_td_from x)))
     (filter
        (<span class="kr">fun</span> <span class="nv">x</span> : CIS1_transfer_data =&gt;
         address_is_contract (cis1_td_to x))
        transfers))</span></span></span><br><span><var>next_st, prev_st, st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>token_id_exists prev_st (cis1_td_token_id a) =
true</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>token_id_exists st (cis1_td_token_id a) = true</span></span></span><br><span><var>Hsingle</var><span class="hyp-type"><b>: </b><span>transfer_single_spec prev_st st
  (cis1_td_token_id a) p q 
  (cis1_td_from a) (cis1_td_to a)
  (cis1_td_amount a)</span></span></span><br><span><var>Htrs</var><span class="hyp-type"><b>: </b><span>compose_transfers st next_st transfers
  (<span class="kr">fun</span> (<span class="nv">st1</span> <span class="nv">st2</span> : Storage)
     (<span class="nv">x</span> : CIS1_transfer_data)
     (<span class="nv">p0</span> : token_id_exists st1
             (cis1_td_token_id x) = true)
     (<span class="nv">q0</span> : token_id_exists st2
             (cis1_td_token_id x) = true) =&gt;
   transfer_single_spec st1 st2
     (cis1_td_token_id x) p0 q0
     (cis1_td_from x) 
     (cis1_td_to x) (cis1_td_amount x))</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances st token_id (get_owners st token_id) =
sum_balances next_st token_id owners2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> IHtransfers;<span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk177"><span class="kn">Lemma</span> <span class="nf">balanceOf_preserves_sum_of_balances</span> `{ChainBase} params prev_st next_st token_id ops
    (spec : balanceOf_spec params prev_st next_st ops) :
    <span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
    sum_balances next_st token_id owners2 =
    sum_balances prev_st token_id owners1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>balanceOf_spec params prev_st next_st ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk178"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>balanceOf_spec params prev_st next_st ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk179"><span class="nb">intros</span> ??.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>balanceOf_spec params prev_st next_st ops</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk17a"><span class="nb">destruct</span> spec <span class="kr">as</span> [H1 H2 H3 H4].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> get_balances prev_st params <span class="kr">with</span>
| Some query_results =&gt;
    <span class="kr">let</span> <span class="nv">serialized_query_results</span> :=
      serialize query_results <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">op</span> :=
      act_call (cis1_bo_result_address params) <span class="mi">0</span>
        serialized_query_results <span class="kr">in</span>
    ops = [op]
| None =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk17b"><span class="nb">clear</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk17c"><span class="nb">apply</span> sum_of_balances_eq_extensional;<span class="nb">subst</span> owners1 owners2;<span class="nb">auto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk17d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk17e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
get_operators next_st addr0 =
get_operators prev_st addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr0</span> : Address),
get_balance_opt next_st token_id0 addr0 =
get_balance_opt prev_st token_id0 addr0</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk17f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk17f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk180"><span class="bp">now</span> <span class="nb">apply</span> same_owners.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr</span> : Address,
get_operators next_st addr =
get_operators prev_st addr</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr</span> : Address),
get_balance_opt next_st token_id0 addr =
get_balance_opt prev_st token_id0 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk181"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_balanceOf_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">addr0</span> : Address,
get_operators next_st addr0 =
get_operators prev_st addr0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">token_id0</span> : TokenID) (<span class="nv">addr0</span> : Address),
get_balance_opt next_st token_id0 addr0 =
get_balance_opt prev_st token_id0 addr0</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> get_balance_opt_default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk182"><span class="kn">Lemma</span> <span class="nf">updateOperator_preserves_sum_of_balances</span> `{ChainBase} params prev_st next_st token_id ops ctx
    (spec : updateOperator_spec ctx params prev_st next_st ops) :
    <span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
    sum_balances next_st token_id owners2 =
    sum_balances prev_st token_id owners1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>updateOperator_spec ctx params prev_st next_st
  ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk183"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>updateOperator_spec ctx params prev_st next_st
  ops</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">owners1</span> := get_owners prev_st token_id <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">owners2</span> := get_owners next_st token_id <span class="kr">in</span>
sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk184"><span class="nb">intros</span> ??.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>spec</var><span class="hyp-type"><b>: </b><span>updateOperator_spec ctx params prev_st next_st
  ops</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk185"><span class="nb">destruct</span> spec <span class="kr">as</span> [H1 H2 H3].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr =
get_balance_opt next_st token_id0 addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br><span><var>owners1</var><span><span class="hyp-body"><b>:= </b><span>get_owners prev_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br><span><var>owners2</var><span><span class="hyp-body"><b>:= </b><span>get_owners next_st token_id</span></span><span class="hyp-type"><b>: </b><span>list Address</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_balances next_st token_id owners2 =
sum_balances prev_st token_id owners1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk186"><span class="nb">apply</span> sum_of_balances_eq_extensional;<span class="nb">subst</span> owners1 owners2;<span class="nb">auto with</span> hints.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr =
get_balance_opt next_st token_id0 addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk187" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr =
get_balance_opt next_st token_id0 addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk187"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk188"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr0 =
get_balance_opt next_st token_id0 addr0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In addr (get_owners next_st token_id) &lt;-&gt;
In addr (get_owners prev_st token_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="CIS1Spec-v-chk189" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr =
get_balance_opt next_st token_id0 addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br></div><label class="goal-separator" for="CIS1Spec-v-chk189"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk18a"><span class="bp">now</span> <span class="nb">apply</span> same_owners.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr =
get_balance_opt next_st token_id0 addr</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">addr</span> : Address,
In addr (get_owners next_st token_id) -&gt;
get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="CIS1Spec-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="CIS1Spec-v-chk18b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ChainBase</span></span></span><br><span><var>params</var><span class="hyp-type"><b>: </b><span>CIS1_updateOperator_params</span></span></span><br><span><var>prev_st, next_st</var><span class="hyp-type"><b>: </b><span>Storage</span></span></span><br><span><var>token_id</var><span class="hyp-type"><b>: </b><span>TokenID</span></span></span><br><span><var>ops</var><span class="hyp-type"><b>: </b><span>list ActionBody</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>ContractCallContext</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">token_id0</span> : TokenID,
token_id_exists prev_st token_id0 =
token_id_exists next_st token_id0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">addr0</span> : Address) (<span class="nv">token_id0</span> : TokenID),
get_balance_opt prev_st token_id0 addr0 =
get_balance_opt next_st token_id0 addr0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>compose_uptadeOperator_specs ctx prev_st next_st
  (cis1_ou_params params)</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>Address</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In addr (get_owners next_st token_id)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">get_balance_default next_st token_id addr =
get_balance_default prev_st token_id addr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> get_balance_opt_default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CIS1Balances</span>.</span></span></pre></article></body></html>